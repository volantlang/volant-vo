
import "io.vo";
import "tokens.vo";
import "ast.vo";
import "lexer.vo";
import "mem.vo";

struct ParserState {
	buff:	 *i8;
	line:	  size_t;
	column:   size_t;
};

struct ParserContext {
	stack: vec ast.StmtType;
};
func NewParserContext() ParserContext {
	return (ParserContext){stack: (vec ast.StmtType){}};
};

export struct Parser {
	lexer:	   lexer.Lexer;
	current:   tokens.Token;
	context:   ParserContext;

	func peek(self: *Parser) tokens.Token {
		return self.current;
	};
	func eat(self: *Parser) {
		self.current = self.lexer.next();
	};
	func eatRaw(self: *Parser) {
		self.current = self.lexer.nextRaw();
	};
	func clean(self: *Parser) {
		if self.peek().pType == tokens.PTokenType.SPACE {
			self.eatRaw();
		}
	};
	func error(self: *Parser, msg: *i8) {
		$printf("Error %zu:%zu ", self.lexer.line, self.lexer.column);
		io.println(msg);
		$exit(1);
	};
	func state(self: *Parser) ParserState {
		return (ParserState){line: self.current.line, column: self.current.column, buff: self.current.buff};
	};
	func stmtNode(self: *Parser, state: *ParserState) *ast.Stmt {
		return new ast.Stmt{
			line:   state.line,
			column: state.column,
			buff:   state.buff,
			len:	cast(size_t)(self.current.buff - state.buff)
		};
	};
	func exprNode(self: *Parser, state: *ParserState) *ast.Expr {
		return new ast.Expr{
			line:   state.line,
			column: state.column,
			buff:   state.buff,
			len:	cast(size_t)(self.current.buff - state.buff)
		};
	};
	func typeNode(self: *Parser, state: *ParserState) *ast.Type {
		return new ast.Type{
			line:   state.line,
			column: state.column,
			buff:   state.buff,
			len:	cast(size_t)(self.current.buff - state.buff)
		};
	};
	func patternNode(self: *Parser, state: *ParserState) *ast.Pattern {
		return new ast.Pattern{
			line:   state.line,
			column: state.column,
			buff:   state.buff,
			len:	cast(size_t)(self.current.buff - state.buff)
		};
	};
	func expectPri(self: *Parser, t: tokens.PTokenType) tokens.Token {
		tok := self.peek();
		if tok.pType == t {
			return tok;
		} else {
			$printf("%u\n", t);
			tok.print();
			self.error("expected {t}, got {tok.pType}.");
		}
		return tok;
	};
	func expectSec(self: *Parser, t: tokens.STokenType) tokens.Token {
		tok := self.peek();
		if tok.sType == t {
			return tok;
		} else {
			$printf("%u\n", t);
			tok.print();
			self.error("expected {t}, got {tok.pType}.");
		}
		return tok;
	};
	func assert(self: *Parser, cond: bool, msg: *i8) {
		if cond {
			return;
		} else {
			self.error(msg);
		}
	};
	func identVec(self: *Parser) vec ast.IdentExpr {
		idents := (vec ast.IdentExpr){};
		idents.push((ast.IdentExpr){self.expectPri(tokens.PTokenType.IDENT)});
		self.eat();

		for self.peek().sType == tokens.STokenType.COMMA {
			self.eat();
			idents.push((ast.IdentExpr){self.expectPri(tokens.PTokenType.IDENT)});
			self.eat();
		}
		return idents;
	};
	func typeVec(self: *Parser) vec *ast.Type {
		types := (vec *ast.Type){};
		types.push(self.type());

		for self.peek().sType == tokens.STokenType.COMMA {
			self.eat();
			types.push(self.type());
		}
		return types;
	};
	func exprVec(self: *Parser) vec *ast.Expr {
		exprs := (vec *ast.Expr){};
		exprs.push(self.expr());

		for tok := self.peek(); tok.sType == tokens.STokenType.COMMA; tok = self.peek() {
			self.eat();
			exprs.push(self.expr());
		}
		return exprs;
	};
	func patternVec(self: *Parser) vec *ast.Pattern {
		patterns := (vec *ast.Pattern){};
		patterns.push(self.pattern());

		for tok := self.peek(); tok.sType == tokens.STokenType.COMMA; tok = self.peek() {
			self.eat();
			patterns.push(self.pattern());
		}
		return patterns;
	};
	func file(self: *Parser) ast.File {
		self.eat();
		stmts := (vec *ast.Stmt){};

		for tok := self.peek(); tok.pType != tokens.PTokenType.EOF; tok = self.peek() {
			stmt := self.globalStmt();
			stmts.push(stmt);
		}
		return (ast.File){stmts: stmts};
	};
	func globalStmt(self: *Parser) *ast.Stmt {
		s := self.globalStmtRaw();

		self.expectPri(tokens.PTokenType.SEMICOLON);
		self.eat();
		
		return s;
	};
	func globalStmtRaw(self: *Parser) *ast.Stmt {
		tok := self.peek();
		
		switch tok.pType {
		case tokens.PTokenType.IDENT:
			return self.dec();
		case tokens.PTokenType.SEMICOLON:
			return self.nullStmt();
		default:
			break;
		}
		switch tok.sType {
		case tokens.STokenType.IMPORT:
			return self.imprt();
		case tokens.STokenType.STRUCT:
			return self.structTypedef();
		case tokens.STokenType.ENUM:
			return self.enumTypedef();
		case tokens.STokenType.TUPLE:
			return self.tupleTypedef();
		case tokens.STokenType.UNION:
			return self.unionTypedef();
		case tokens.STokenType.TYPEDEF:
			return self.tdef();
		case tokens.STokenType.TEMPLATE:
			return self.tmplate();
		case tokens.STokenType.__C:
			return self.___c();
		case tokens.STokenType.REGISTER:
		case tokens.STokenType.STATIC:
		case tokens.STokenType.AUTO:
		case tokens.STokenType.EXTERN:
		case tokens.STokenType.C_EXTERN:
			return self.dec();
		/*
		case tokens.STokenType.EXTERN:
			return self.extrn();
		case tokens.STokenType.EXPORT:
			return self.exprt();
		*/
		case tokens.STokenType.FUNC:
			return self.funcDec();
		default:
			return null;
		}
	};
	func localStmt(self: *Parser) *ast.Stmt {
		s := self.localStmtRaw();

		if self.peek().pType == tokens.PTokenType.SEMICOLON {
			self.eat();
		}
		return s;
	};
	func localStmtRaw(self: *Parser) *ast.Stmt {
		tok := self.peek();
		
		switch tok.pType {
		case tokens.PTokenType.LCBRACE:
			return self.block();
		case tokens.PTokenType.SEMICOLON:
			return self.nullStmt();
		default:
			break;
		}
		switch tok.sType {
		case tokens.STokenType.RETURN:
			return self.rturn();
		case tokens.STokenType.FUNC:
			return self.funcDec();
		case tokens.STokenType.IF:
			return self.ifElse();
		case tokens.STokenType.SWITCH:
			return self.swtch();
		case tokens.STokenType.GENERIC:
			return self.genric();
		case tokens.STokenType.FOR:
			return self.loop();
		case tokens.STokenType.MATCH:
			return self.mtch();
		case tokens.STokenType.DELETE:
			return self.del();
		case tokens.STokenType.BREAK:
			goto brak;
		case tokens.STokenType.CONTINUE:
			goto continuee;
		case tokens.STokenType.STRUCT:
			return self.structTypedef();
		case tokens.STokenType.ENUM:
			return self.enumTypedef();
		case tokens.STokenType.TUPLE:
			return self.tupleTypedef();
		case tokens.STokenType.UNION:
			return self.unionTypedef();
		case tokens.STokenType.TYPEDEF:
			return self.tdef();
		case tokens.STokenType.LABEL:
			return self.labl();
		case tokens.STokenType.GOTO:
			return self.gotoh();
		case tokens.STokenType.__C:
			return self.___c();
		case tokens.STokenType.REGISTER:
		case tokens.STokenType.STATIC:
		case tokens.STokenType.AUTO:
		case tokens.STokenType.EXTERN:
		case tokens.STokenType.C_EXTERN:
			return self.dec();
		case tokens.STokenType.CASE:
			goto casee;
		case tokens.STokenType.DEFAULT:
			goto defalt;
		default:
			return self.decAssignExpr();
		}
	
	label brak:
		// if self.context.inLoop || self.context.inSwitch || self.context.inMatch || self.context.inGeneric {
			return self.brak();
		// }
		// self.error("bruh break not allowed outside loops, match and switch statements.");
	label continuee:
		// if self.context.inLoop {
			return self.continuee();
		// }
		// self.error("bruh continue not allowed outside loops.");
	label casee:
		if self.context.stack.length > 0 {
			x: ast.StmtType = self.context.stack[self.context.stack.length - 1];
			for i := self.context.stack.length; i >= 0 && x != ast.StmtType.SWITCH && x != ast.StmtType.MATCH && x != ast.StmtType.GENERIC; x = self.context.stack[--i] {}

			if x == ast.StmtType.SWITCH {
				return self.switchCase();
			} else if x == ast.StmtType.MATCH {
				return self.matchCase();
			} else if x == ast.StmtType.GENERIC {
				return self.genericCase();
			}
		}
		self.error("bruh case not allowed outside switch and match statements.");
	label defalt:
		// if self.context.inSwitch || self.context.inMatch || self.context.inGeneric {
			return self.defalt();
		// }
		// self.error("bruh default not allowed outside switch/match/generic statements.");
		// return null;
	};
	func basicStmt(self: *Parser) *ast.Stmt {
		tok := self.peek();
		
		switch tok.pType {
		case tokens.PTokenType.IDENT:
			return self.decAssignExpr();
		case tokens.PTokenType.SEMICOLON:
			return self.nullStmt();
		default:
			break;
		}
		switch tok.sType {
		case tokens.STokenType.LABEL:
			return self.labl();
		case tokens.STokenType.CASE:
			goto casee;
		case tokens.STokenType.DEFAULT:
			goto defalt;
		default:
			return self.exprStmt();
		}

	label casee:
		if self.context.stack.length > 0 {
			x: ast.StmtType = self.context.stack[self.context.stack.length - 1];
			for i := self.context.stack.length; i >= 0 && x != ast.StmtType.SWITCH && x != ast.StmtType.MATCH; x = self.context.stack[--i] {}

			if x == ast.StmtType.SWITCH {
				return self.switchCase();
			} else if x == ast.StmtType.MATCH {
				return self.matchCase();
			}
		}
	label defalt:
		// if self.context.inSwitch || self.context.inMatch {
			return self.defalt();
		// }
		// self.error("bruh default not allowed outside switch statements.");
		// return null;
	};
	func nullStmt(self: *Parser) *ast.Stmt {
		state := self.state();
		self.eat();
		
		stmt := self.stmtNode(&state);
		stmt.type = ast.StmtType.NULL;
		return stmt;
	};
	func brak(self: *Parser) *ast.Stmt {
		state := self.state();
		self.eat();
		
		stmt := self.stmtNode(&state);
		stmt.type = ast.StmtType.BREAK;
		
		return stmt;
	};
	func continuee(self: *Parser) *ast.Stmt {
		state := self.state();
		self.eat();
		
		stmt := self.stmtNode(&state);
		stmt.type = ast.StmtType.CONTINUE;
		
		return stmt;
	};
	func defalt(self: *Parser) *ast.Stmt {
		state := self.state();
		self.eat();
		self.expectSec(tokens.STokenType.COLON);
		self.eat();

		stmt := self.stmtNode(&state);
		stmt.type = ast.StmtType.DEFAULT;
		
		return stmt;
	};
	func exprStmt(self: *Parser) *ast.Stmt {
		state := self.state();
		expr := self.expr();

		stmt := self.stmtNode(&state);
		stmt.type = ast.StmtType.EXPR;
		stmt.data.expr = (ast.ExprStmt){expr};
		
		return stmt;
	};
	func rturn(self: *Parser) *ast.Stmt {
		state := self.state();
		rturn := self.rturnRaw();

		stmt := self.stmtNode(&state);
		stmt.type = ast.StmtType.RETURN;
		stmt.data.rturn = rturn;
		return stmt;
	};
	func rturnRaw(self: *Parser) ast.Return {
		self.eat();
		return (ast.Return){val: self.expr()};
	};
	func switchCase(self: *Parser) *ast.Stmt {
		state := self.state();
		scase := self.switchCaseRaw();

		stmt := self.stmtNode(&state);
		stmt.type = ast.StmtType.SCASE;
		stmt.data.scase = scase;
		return stmt;
	};
	func switchCaseRaw(self: *Parser) ast.SwitchCase {
		self.eat();
		c := (ast.SwitchCase){val: self.expr()};
		self.expectSec(tokens.STokenType.COLON);
		self.eat();
		return c;
	};
	func matchCase(self: *Parser) *ast.Stmt {
		state := self.state();
		mcase := self.matchCaseRaw();

		stmt := self.stmtNode(&state);
		stmt.type = ast.StmtType.MCASE;
		stmt.data.mcase = mcase;
		return stmt;
	};
	func matchCaseRaw(self: *Parser) ast.MatchCase {
		self.eat();
		c := (ast.MatchCase){val: self.pattern()};
		self.expectSec(tokens.STokenType.COLON);
		self.eat();
		return c;
	};
	func genericCase(self: *Parser) *ast.Stmt {
		state := self.state();
		gcase := self.genericCaseRaw();

		stmt := self.stmtNode(&state);
		stmt.type = ast.StmtType.GCASE;
		stmt.data.gcase = gcase;
		return stmt;
	};
	func genericCaseRaw(self: *Parser) ast.GenericCase {
		self.eat();
		c := (ast.GenericCase){val: self.type()};
		self.expectSec(tokens.STokenType.COLON);
		self.eat();
		return c;
	};
	func block(self: *Parser) *ast.Stmt {
		state := self.state();
		block := self.blockRaw();
		stmt := self.stmtNode(&state);
		
		stmt.type = ast.StmtType.BLOCK;
		stmt.data.block = block;
		
		return stmt;
	};
	func blockRaw(self: *Parser) ast.Block {
		self.eat();
		block := (ast.Block){stmts: (vec ast.Stmt){}};
		
		for self.peek().pType != tokens.PTokenType.RCBRACE {
			block.stmts.push(self.localStmt());
		}
		self.eat();
		return block;
	};
	func imprt(self: *Parser) *ast.Stmt {
		state := self.state();
		imprt := self.imprtRaw();
		stmt := self.stmtNode(&state);

		stmt.type = ast.StmtType.IMPORT;
		stmt.data.imprt = imprt;
		
		return stmt;
	};
	func imprtRaw(self: *Parser) ast.Import {
		imprt := (ast.Import){};

		self.eat();
		imprt.path = new ast.BasicLit{self.expectPri(tokens.PTokenType.STR_LIT)};
		self.eat();

		if self.peek().pType == tokens.STokenType.AS {
			self.eat();
			imprt.name = new ast.IdentExpr{self.expectPri(tokens.PTokenType.IDENT)};
			self.eat();
		} else {
			/*
			imprt.name = cast(*ast.IdentExpr)(new tokens.Token{

			});
			*/
		}
		return imprt;
	};
	func decAssignExpr(self: *Parser) *ast.Stmt {
		state := self.state();
		exprs := self.exprVec();

		if tok := self.peek(); tok.sType == tokens.STokenType.COLON {
			return self.decBody(&state, exprs);
		} else if tok.pType == tokens.PTokenType.ASSIGN_OP {
			return self.assignBody(&state, exprs);
		} else if exprs.length == 1 {
			stmt := self.stmtNode(&state);
			stmt.type = ast.StmtType.EXPR;
			stmt.data.expr = (ast.ExprStmt){expr: exprs[0]};
			exprs.free();
			return stmt;
		}
		
		self.error("expected assignment operator, got {s}.");
		return null;
	};
	func dec(self: *Parser) *ast.Stmt {
		state := self.state();
		t: ast.StorageClass;

		switch self.peek().sType {
		case tokens.STokenType.AUTO:
			t = ast.StorageClass.AUTO;
			self.eat();
			break;
		case tokens.STokenType.REGISTER:
			t = ast.StorageClass.REGISTER;
			self.eat();
			break;
		case tokens.STokenType.C_EXTERN:
			t = ast.StorageClass.C_EXTERN;
			self.eat();
			break;
		case tokens.STokenType.EXTERN:
			t = ast.StorageClass.EXTERN;
			self.eat();
			break;
		case tokens.STokenType.STATIC:
			t = ast.StorageClass.STATIC;
			self.eat();
			break;
		default:
			t = ast.StorageClass.AUTO;
			break;
		}
		idents := self.exprVec();

		s := self.decBody(&state, idents);
		s.data.dec.sClass = t;
		return s;
	};
	func decBodyRaw(self: *Parser, e: *void) ast.Declaration {
		exprs := cast(vec *ast.Expr)e;
		
		for i := 0; i < exprs.length; ++i {
			self.assert(exprs[i].type == ast.ExprType.IDENT, "bruh gib identifiers.");
		}
		self.eat();
		dec := (ast.Declaration){idents: exprs};
		
		if self.peek().sType != tokens.STokenType.EQ {
			dec.types = self.typeVec();
		} else {
			dec.types = (vec *ast.Type){};
			goto eq;
		}

		if self.peek().sType == tokens.STokenType.EQ {
		label eq:
			self.eat();
			dec.values = self.exprVec();
		} else {
			dec.values = null;
		}
		return dec;
	};
	func decBody(self: *Parser, statePtr: *ParserState, e: *void) *ast.Stmt {
		dec := self.decBodyRaw(e);

		stmt := self.stmtNode(statePtr);
		stmt.type = ast.StmtType.DEC;
		stmt.data.dec = dec;
		return stmt;
	};
	func decNoVal(self: *Parser) *ast.Stmt {
		state := self.state();
		dec := self.decNoValRaw();

		stmt := self.stmtNode(&state);
		stmt.type = ast.StmtType.DEC;
		stmt.data.dec = dec;
		return stmt;
	};
	func decNoValRaw(self: *Parser) ast.Declaration {
		dec := (ast.Declaration){idents: self.exprVec()};

		self.expectSec(tokens.STokenType.COLON);
		self.eat();

		dec.types = self.typeVec();
		dec.values = null;

		return dec;
	};
	func assignBody(self: *Parser, statePtr: *ParserState, e: *void) *ast.Stmt {
		exprs := cast(vec *ast.Expr)e;
		assign := (ast.Assignment){};

		for i := 0; i < exprs.length; ++i {
			expr := exprs[i];
			self.assert((
				expr.type == ast.ExprType.IDENT   ||
				expr.type == ast.ExprType.MEMBER  ||
				expr.type == ast.ExprType.ELEMENT ||
				(expr.type == ast.ExprType.UNARY && (cast(*ast.Operator)(expr.data.unary.op)).tok.sType == tokens.STokenType.MUL)
			), "bruh gib identifiers.");
		}

		assign.vars = exprs;
		assign.op = new (ast.Operator){self.peek()};

		self.eat();
		assign.vals = self.exprVec();

		stmt := self.stmtNode(statePtr);
		stmt.type = ast.StmtType.ASSIGN;
		stmt.data.assign = assign;
		return stmt;
	};
	func funcDec(self: *Parser) *ast.Stmt {
		state := self.state();
		dec := self.funcDecRaw();

		stmt := self.stmtNode(&state);
		stmt.type = ast.StmtType.FUNC;
		stmt.data.funcDec = dec;
		return stmt;
	};
	func funcDecNoBlock(self: *Parser) *ast.Stmt {
		state := self.state();
		dec := self.funcDecRawNoBlock();

		stmt := self.stmtNode(&state);
		stmt.type = ast.StmtType.FUNC;
		stmt.data.funcDec = dec;
		return stmt;
	};
	func funcDecRawNoBlock(self: *Parser) ast.FuncDec {
		self.eat();

		dec := (ast.FuncDec){};
		dec.type.args.names = (vec ast.IdentExpr){};
		dec.type.args.types = (vec *ast.Type){};
		dec.type.varargs = null;

		tok := self.peek();

		if tok.pType == tokens.PTokenType.IDENT {
			dec.type.type = ast.FuncTypeEnum.NATIVE;
			dec.name = new ast.IdentExpr{tok};
			goto funcBody;
		}

		switch tok.sType {
		case tokens.STokenType.WORK:
			dec.type.type = ast.FuncTypeEnum.WORK;
			self.eat();
			break;
		case tokens.STokenType.ASYNC:
			dec.type.type = ast.FuncTypeEnum.ASYNC;
			self.eat();
			break;
		case tokens.STokenType.NATIVE:
			dec.type.type = ast.FuncTypeEnum.NATIVE;
			self.eat();
			break;
		default:
			dec.type.type = ast.FuncTypeEnum.NATIVE;
			break;
		}
		dec.name = new ast.IdentExpr{self.expectPri(tokens.PTokenType.IDENT)};
		
	label funcBody:
		self.eat();
		self.expectPri(tokens.PTokenType.LPAREN);
		self.eat();

		if self.peek().pType == tokens.PTokenType.RPAREN {
			goto next;
		}
		goto body;

		for self.peek().sType == tokens.STokenType.COMMA {
			self.eat();

		label body:
			if tok := self.peek(); tok.pType == tokens.PTokenType.IDENT {
				dec.type.args.names.push((ast.IdentExpr){tok: tok});
				self.eat();
				self.expectSec(tokens.STokenType.COLON);
				self.eat();
				dec.type.args.types.push(self.type());
			} else if tok.sType == tokens.STokenType.DOTDOT {
				self.eat();
				dec.type.varargs = new ast.IdentExpr{tok: self.expectPri(tokens.PTokenType.IDENT)};
				self.eat();
				break;
			} else {
				self.error("bruhhh");
			}
		}
		self.expectPri(tokens.PTokenType.RPAREN);

	label next:
		self.eat();

		if p := self.peek().pType; 
			p == tokens.PTokenType.LCBRACE   || 
			p == tokens.PTokenType.RPAREN    ||
			p == tokens.PTokenType.SEMICOLON {
			dec.type.returnType = null;
		} else {
			dec.type.returnType = self.type();
			self.expectPri(tokens.PTokenType.LCBRACE);
		}
		return dec;
	};
	func funcDecRaw(self: *Parser) ast.FuncDec {
		dec := self.funcDecRawNoBlock();
		dec.body = self.blockRaw();
		return dec;
	};
	func labl(self: *Parser) *ast.Stmt {
		state := self.state();
		labl := self.lablRaw();

		stmt := self.stmtNode(&state);
		stmt.type = ast.StmtType.LABEL;
		stmt.data.labl = labl;
		return stmt;
	};
	func lablRaw(self: *Parser) ast.Label {
		self.eat();
		name := new ast.IdentExpr{self.expectPri(tokens.PTokenType.IDENT)};
		self.eat();
		self.expectSec(tokens.STokenType.COLON);
		self.eat();
		return (ast.Label){name};
	};
	func gotoh(self: *Parser) *ast.Stmt {
		state := self.state();
		gotoh := self.gotohRaw();

		stmt := self.stmtNode(&state);
		stmt.type = ast.StmtType.GOTO;
		stmt.data.gotoh = gotoh;
		return stmt;
	};
	func gotohRaw(self: *Parser) ast.Goto {
		self.eat();
		name := new ast.IdentExpr{self.expectPri(tokens.PTokenType.IDENT)};
		self.eat();
		return (ast.Goto){name};
	};
	func ifElse(self: *Parser) *ast.Stmt {
		state := self.state();
		ifElse := self.ifElseRaw();

		stmt := self.stmtNode(&state);
		stmt.type = ast.StmtType.IF_ELSE;
		stmt.data.ifElse = ifElse;
		return stmt;
	};
	func ifElseRaw(self: *Parser) ast.IfElse {
		ifElse := (ast.IfElse){
			conds:	 (vec *ast.Expr){}, 
			initStmts: (vec *ast.Stmt){},
			blocks:	(vec ast.Block){}
		};
		
	label body:
		self.eat();
		stmt := self.basicStmt();
			
		switch self.peek().pType {
		case tokens.PTokenType.LCBRACE:
			ifElse.initStmts.push(null);

			self.assert(stmt.type == ast.StmtType.EXPR, "bruh gib expression not statement");
			ifElse.conds.push(stmt.data.expr.expr);
			delete stmt;
			break;
		case tokens.PTokenType.SEMICOLON:
			self.eat();
			ifElse.initStmts.push(stmt);

			ifElse.conds.push(self.expr());
			self.expectPri(tokens.PTokenType.LCBRACE);
			break;
		default:
			break;
		}
		ifElse.blocks.push(self.blockRaw());
		
		if self.peek().sType != tokens.STokenType.ELSE {
			ifElse.elseBlock = (ast.Block){stmts: null};
			return ifElse;
		}
		self.eat();

		if self.peek().sType == tokens.STokenType.IF {
			goto body;
		}
		self.expectPri(tokens.PTokenType.LCBRACE);
		ifElse.elseBlock = self.blockRaw();
		return ifElse;
	};
	func swtch(self: *Parser) *ast.Stmt {
		state := self.state();
		swtch := self.swtchRaw();
		
		stmt := self.stmtNode(&state);
		stmt.type = ast.StmtType.SWITCH;
		stmt.data.swtch = swtch;
		return stmt;
	};
	func swtchRaw(self: *Parser) ast.Switch {
		self.eat();
		swtch := (ast.Switch){};
		
		if stmt := self.basicStmt(); self.peek().pType == tokens.PTokenType.LCBRACE {
			self.assert(stmt.type == ast.StmtType.EXPR, "bruh gib expression, not type");
			swtch.initStmt = null;
			swtch.expr = stmt.data.expr.expr;
			delete stmt;
		} else {
			swtch.initStmt = stmt;
			self.expectPri(tokens.PTokenType.SEMICOLON);
			self.eat();
			swtch.expr = self.expr();
			self.expectPri(tokens.PTokenType.LCBRACE);
		}
		self.context.stack.push(ast.StmtType.SWITCH);
		swtch.block = self.blockRaw();
		self.context.stack.pop();
		return swtch;
	};
	func genric(self: *Parser) *ast.Stmt {
		state := self.state();
		genric := self.genricRaw();
		
		stmt := self.stmtNode(&state);
		stmt.type = ast.StmtType.GENERIC;
		stmt.data.genric = genric;
		return stmt;
	};
	func genricRaw(self: *Parser) ast.Generic {
		self.eat();
		genric := (ast.Generic){};
		/*
		if stmt := self.basicStmt(); self.peek().pType == tokens.PTokenType.LCBRACE {
			self.assert(stmt.type == ast.StmtType.EXPR, "bruh gib expression, not type");
			genric.initStmt = null;
			genric.type = stmt.data.expr.expr;
			delete stmt;
		} else {
			genric.initStmt = stmt;
			self.expectPri(tokens.PTokenType.SEMICOLON);
			self.eat();
		*/
			genric.initStmt = null;
			genric.type = self.type();
			self.expectPri(tokens.PTokenType.LCBRACE);
		// }
		self.context.stack.push(ast.StmtType.GENERIC);
		genric.block = self.blockRaw();
		self.context.stack.pop();
		return genric;
	};
	func loop(self: *Parser) *ast.Stmt {
		state := self.state();
		loop := self.loopRaw();
		
		stmt := self.stmtNode(&state);
		stmt.type = ast.StmtType.LOOP;
		stmt.data.loop = loop;
		return stmt;
	};
	func loopRaw(self: *Parser) ast.Loop {
		self.eat();
		loop := (ast.Loop){};

		if p := self.peek().pType; p == tokens.PTokenType.LCBRACE {
			loop.initStmt = null;
			loop.cond = null;
			loop.loopStmt = null;
			goto end;
		} else if p == tokens.PTokenType.SEMICOLON {
			loop.initStmt = null;
			goto cond;
		}
		stmt := self.basicStmt();

		if self.peek().pType == tokens.PTokenType.SEMICOLON {
			loop.initStmt = stmt;
		} else if stmt.type == ast.StmtType.EXPR {
			loop.initStmt = null;
			loop.cond = stmt.data.expr.expr;
			delete stmt;
			goto afterCond;
		} else {
			self.error("buh gib expression");
		}
	label cond:
		self.eat();
		if p := self.peek().pType; p == tokens.PTokenType.LCBRACE {
			loop.cond = null;
			loop.loopStmt = null;
			goto end;
		} else if p != tokens.PTokenType.SEMICOLON {
			loop.cond = self.expr();
		} else {
			loop.cond = null;
			goto final;
		}
	label afterCond:
		if p := self.peek().pType; p == tokens.PTokenType.LCBRACE {
			loop.loopStmt = null;
			goto end;
		} else if p != tokens.PTokenType.SEMICOLON {
			self.error("buh gib semicolon");	
		}
	label final:
		self.eat();
		if self.peek().pType == tokens.PTokenType.LCBRACE {
			loop.loopStmt = null;
		} else {
			loop.loopStmt = self.basicStmt();
		}
	label end:
		self.context.stack.push(ast.StmtType.LOOP);
		loop.block = self.blockRaw();
		self.context.stack.pop();
		return loop;
	};
	func mtch(self: *Parser) *ast.Stmt {
		state := self.state();
		mtch := self.mtchRaw();
		
		stmt := self.stmtNode(&state);
		stmt.type = ast.StmtType.MATCH;
		stmt.data.mtch = mtch;
		return stmt;
	};
	func mtchRaw(self: *Parser) ast.Match {
		self.eat();
		mtch := (ast.Match){};
		
		if stmt := self.basicStmt(); self.peek().pType == tokens.PTokenType.LCBRACE {
			self.assert(stmt.type == ast.StmtType.EXPR, "bruh gib expression, not type");
			mtch.initStmt = null;
			mtch.expr = stmt.data.expr.expr;
			delete stmt;
		} else {
			mtch.initStmt = stmt;
			self.expectPri(tokens.PTokenType.SEMICOLON);
			self.eat();
			mtch.expr = self.expr();
			self.expectPri(tokens.PTokenType.LCBRACE);
		}
		self.context.stack.push(ast.StmtType.MATCH);
		mtch.block = self.blockRaw();
		self.context.stack.pop();
		return mtch;
	};
	func del(self: *Parser) *ast.Stmt {
		state := self.state();
		del := self.delRaw();
		
		stmt := self.stmtNode(&state);
		stmt.type = ast.StmtType.DELETE;
		stmt.data.del = del;
		return stmt;
	};
	func delRaw(self: *Parser) ast.Delete {
		self.eat();
		return (ast.Delete){exprs: self.exprVec()};
	};
	func tdef(self: *Parser) *ast.Stmt {
		state := self.state();
		tdef := self.tdefRaw();
		
		stmt := self.stmtNode(&state);
		stmt.type = ast.StmtType.TYPEDEF;
		stmt.data.tdef = tdef;
		return stmt;
	};
	func tdefRaw(self: *Parser) ast.Typedef {
		self.eat();
		tdef := (ast.Typedef){};

		tdef.name = new ast.IdentExpr{self.expectPri(tokens.PTokenType.IDENT)};
		self.eat();

		tdef.type = self.type();
		return tdef;
	};
	func tmplate(self: *Parser) *ast.Stmt {
		state := self.state();
		tmplate := self.tmplateRaw();

		stmt := self.stmtNode(&state);
		stmt.type = ast.StmtType.TEMPLATE;
		stmt.data.tmplate = tmplate;
		return stmt;
	};
	func tmplateRaw(self: *Parser) ast.Template {
		self.eat();

		tmplate := (ast.Template){};
		tmplate.name = new ast.IdentExpr{tok: self.expectPri(tokens.PTokenType.IDENT)};
		self.eat();

		self.expectPri(tokens.PTokenType.LPAREN);
		self.eat();

		tmplate.type.params = self.identVec();
		self.expectPri(tokens.PTokenType.RPAREN);
		self.eat();

		if self.peek().sType == tokens.STokenType.FUNC {
			x := self.funcExpr();
			(cast(*ast.FuncType)x.data.funcExpr.type).type = ast.FuncTypeEnum.NATIVE;

			tmplate.type.data.expr = x;
			tmplate.type.type = ast.TypeExprEnum.EXPR;
		} else {
			tmplate.type.data.type = self.type();
			tmplate.type.type = ast.TypeExprEnum.TYPE;
		}

		tmplate.type.datas = (vec ast.TypeExprUnion){};
		tmplate.type.args = (vec vec *ast.Type){};
		
		return tmplate;
	};
	func ___c(self: *Parser) *ast.Stmt {
		state := self.state();
		___c := self.___cRaw();

		stmt := self.stmtNode(&state);
		stmt.type = ast.StmtType.__C;
		stmt.data.___c = ___c;
		return stmt; 
	};
	func ___cRaw(self: *Parser) ast.__C {
		self.eat();
		self.expectPri(tokens.PTokenType.LCBRACE);
		self.eat();

		___c := (ast.__C){stuff: (vec *ast.Expr){}};
		
		for self.peek().pType != tokens.PTokenType.RCBRACE {
			___c.stuff.push(self.expr());
		}
		self.eat();
		return ___c;
	};
	func expr(self: *Parser) *ast.Expr {
		return self.expr0();
	};
	func expr0(self: *Parser) *ast.Expr { // ?:
		state := self.state();
		cond := self.expr1();

		if tok := self.peek(); tok.sType != tokens.STokenType.QMARK {
			return cond;
		}
		self.eat();
		left := self.expr0();

		self.expectSec(tokens.STokenType.COLON);
		self.eat();

		right := self.expr1();
		ternary := (ast.TernaryExpr){left: left, cond: cond, right: right};
		
		expr := self.exprNode(&state);
		expr.type = ast.ExprType.TERNARY;
		expr.data.ternary = ternary;
		return expr;
	};
	func expr1(self: *Parser) *ast.Expr { // &&, ||
		state := self.state();
		left := self.expr2();

		for tok := self.peek(); tok.pType == tokens.PTokenType.LOGIC_OP; tok = self.peek() {
			self.eat();
			right := self.expr2();
			
			expr := self.exprNode(&state);
			expr.type = ast.ExprType.BINARY;
			expr.data.binary = (ast.BinaryExpr){left: left, op: new ast.Operator{tok}, right: right};
			left = expr;
		}
		return left;
	};
	func expr2(self: *Parser) *ast.Expr { // &, |, ^
		state := self.state();
		left := self.expr3();

		for tok := self.peek(); 
			tok.sType == tokens.STokenType.OR  || 
			tok.sType == tokens.STokenType.AND ||
			tok.sType == tokens.STokenType.XOR;
			tok = self.peek() {
		
			self.eat();
			right := self.expr3();
			expr := self.exprNode(&state);
			expr.type = ast.ExprType.BINARY;
			expr.data.binary = (ast.BinaryExpr){left: left, op: new ast.Operator{tok}, right: right};
			left = expr;
		}
		return left;
	};
	func expr3(self: *Parser) *ast.Expr { // is
		state := self.state();
		left := self.expr4();
		
		for tok := self.peek();
			tok.sType == tokens.STokenType.IS;
			tok = self.peek() {
			
			self.eat();
			pattern := self.pattern();
			expr := self.exprNode(&state);
			expr.type = ast.ExprType.IS;
			expr.data.isExpr = (ast.IsExpr){expr: left, pattern: pattern};
			left = expr;
		}
		return left;
	};
	func expr4(self: *Parser) *ast.Expr { // ==, !=
		state := self.state();
		left := self.expr5();

		for tok := self.peek(); 
			tok.sType == tokens.STokenType.EQEQ  || 
			tok.sType == tokens.STokenType.NOTEQ;
			tok = self.peek() {
		
			self.eat();
			right := self.expr5();
			expr := self.exprNode(&state);
			expr.type = ast.ExprType.BINARY;
			expr.data.binary = (ast.BinaryExpr){left: left, op: new ast.Operator{tok}, right: right};
			left = expr;
		}
		return left;
	};
	func expr5(self: *Parser) *ast.Expr { // >, <, >=, <=
		state := self.state();
		left := self.expr6();

		for tok := self.peek(); 
			tok.sType == tokens.STokenType.GTEQ || 
			tok.sType == tokens.STokenType.LTEQ ||
			tok.sType == tokens.STokenType.GT   || 
			tok.sType == tokens.STokenType.LT;
			tok = self.peek() {
		
			self.eat();
			right := self.expr6();
			expr := self.exprNode(&state);
			expr.type = ast.ExprType.BINARY;
			expr.data.binary = (ast.BinaryExpr){left: left, op: new ast.Operator{tok}, right: right};
			left = expr;
		}
		return left;
	};
	func expr6(self: *Parser) *ast.Expr { // >>, <<
		state := self.state();
		left := self.expr7();

		for tok := self.peek(); 
			tok.sType == tokens.STokenType.LSHIFT || 
			tok.sType == tokens.STokenType.RSHIFT;
			tok = self.peek() {
		
			self.eat();
			right := self.expr7();
			expr := self.exprNode(&state);
			expr.type = ast.ExprType.BINARY;
			expr.data.binary = (ast.BinaryExpr){left: left, op: new ast.Operator{tok}, right: right};
			left = expr;
		}
		return left;
	};
	func expr7(self: *Parser) *ast.Expr { // +, -
		state := self.state();
		left := self.expr8();
		
		for tok := self.peek(); 
			tok.sType == tokens.STokenType.ADD || 
			tok.sType == tokens.STokenType.SUB;
			tok = self.peek() {
			
			self.eat();
			right := self.expr8();
			expr := self.exprNode(&state);
			expr.type = ast.ExprType.BINARY;
			expr.data.binary = (ast.BinaryExpr){left: left, op: new ast.Operator{tok}, right: right};
			left = expr;
		}
		return left;
	};
	func expr8(self: *Parser) *ast.Expr { // /, *, %
		state := self.state();
		left := self.expr9();

		for tok := self.peek(); 
			tok.sType == tokens.STokenType.DIV || 
			tok.sType == tokens.STokenType.MUL || 
			tok.sType == tokens.STokenType.MOD;
			tok = self.peek() {
		
			self.eat();
			right := self.expr9();
			expr := self.exprNode(&state);
			expr.type = ast.ExprType.BINARY;
			expr.data.binary = (ast.BinaryExpr){left: left, op: new ast.Operator{tok}, right: right};
			left = expr;
		}
		return left;
	};
	func expr9(self: *Parser) *ast.Expr { // unuary *, &, +, -, ++, --, !, ~, new, cast, sizeof
		switch tok, state := self.peek(), self.state(); tok.sType {
		case tokens.STokenType.CAST:
			return self.castExpr();
		case tokens.STokenType.AWAIT:
			return self.awaitExpr();
		case tokens.STokenType.SIZEOF:
			return self.sizeExpr();
		case tokens.STokenType.NEW:
			return self.newExpr();
		case tokens.STokenType.SWITCH:
			return self.swtchExpr();
		case tokens.STokenType.MATCH:
			return self.mtchExpr();
		case tokens.STokenType.GENERIC:
			return self.genricExpr();
		case tokens.STokenType.MUL: 
		case tokens.STokenType.AND: 
		case tokens.STokenType.ADD: 
		case tokens.STokenType.SUB: 
		case tokens.STokenType.LNOT: 
		case tokens.STokenType.BNOT: 
		case tokens.STokenType.ADDADD: 
		case tokens.STokenType.SUBSUB:
			self.eat();
			e := self.expr9();
			expr := self.exprNode(&state);
			expr.type = ast.ExprType.UNARY;
			expr.data.unary = (ast.UnaryExpr){expr: e, op: new ast.Operator{tok}};
			return expr;
		default:
			return self.expr10();
		}
	};
	func expr10(self: *Parser) *ast.Expr { // posifix ++, --, function call, element, generic call
		state := self.state();
		e := self.expr11();
		x: *ast.Expr;

	label loop:
		tok := self.peek();
		
		switch tok.pType {
		case tokens.PTokenType.LPAREN:
			e = self.callExpr(e, &state);
			goto loop;
		case tokens.PTokenType.LBRACE:
			self.eat();
			index := self.expr();

			self.expectPri(tokens.PTokenType.RBRACE);
			self.eat();
			
			x = self.exprNode(&state);
			x.type = ast.ExprType.ELEMENT;
			x.data.element = (ast.ElementExpr){base: e, index: index};
			e = x;
			goto loop;
		default:
			break;
		}
		switch tok.sType {
		case tokens.STokenType.ADDADD:
		case tokens.STokenType.SUBSUB:
			self.eat();
			x = self.exprNode(&state);
			x.type = ast.ExprType.PUNARY;
			x.data.unary = (ast.UnaryExpr){expr: e, op: new ast.Operator{tok}};
			e = x;
			goto loop;
		case tokens.STokenType.LNOT:
			e = self.genCallExpr(e, &state);
			goto loop;
		default:
			return e;
		}
	};
	func expr11(self: *Parser) *ast.Expr { // parenthesis, compound literal, array initializer
		state := self.state();

		switch self.peek().pType {
		case tokens.PTokenType.LCBRACE:
			return self.arrayInitializer();
		case tokens.PTokenType.LPAREN:
			break;
		default:
			return self.expr12();
		}
		self.eat();
		e := self.exprOrType();
		
		self.expectPri(tokens.PTokenType.RPAREN);
		self.eatRaw();
		
		if self.peek().pType != tokens.PTokenType.LCBRACE {
			self.assert(e.type == ast.TypeExprEnum.EXPR, "gib expression, not type.");
			self.clean();
			return cast(*ast.Expr)e.data.expr;
		}
		if e.type == ast.TypeExprEnum.EXPR {
			t := self.typeNode(&state);
			t.type = ast.TypeType.EXPR;
			t.data.expr = (ast.BasicExprType){expr: e.data.expr};
			e.data.type = t;
		}
		c := (ast.CompLit){type: e.data.type};
		self.compLitData(&c);

		ee := self.exprNode(&state);
		ee.type = ast.ExprType.COMPLIT;
		ee.data.compLit = c;
		return ee;
	};
	func expr12(self: *Parser) *ast.Expr { // member
		state := self.state();
		e := self.expr13();
		x := e;

		for self.peek().sType == tokens.STokenType.DOT {
			self.eat();
			
			prop := new ast.IdentExpr{self.expectPri(tokens.PTokenType.IDENT)};
			self.eat();
			
			x = self.exprNode(&state);
			x.type = ast.ExprType.MEMBER;
			x.data.member = (ast.MemberExpr){base: e, prop: prop};
			e = x;
		}
		return x;
	};
	func expr13(self: *Parser) *ast.Expr {
		state := self.state();
		tok := self.peek();
		expr: *ast.Expr;
		
		switch tok.pType {
		case tokens.PTokenType.IDENT:
			self.eat();
			expr = self.exprNode(&state);
			expr.type = ast.ExprType.IDENT;
			goto end;
		case tokens.PTokenType.STR_LIT:
			self.eat();
			expr = self.exprNode(&state);
			expr.type = ast.ExprType.STR_LIT;
			goto end;
		case tokens.PTokenType.STR_LIT2:
			self.eat();
			expr = self.exprNode(&state);
			expr.type = ast.ExprType.STR_LIT2;
			goto end;
		case tokens.PTokenType.CHAR_LIT:
			self.eat();
			expr = self.exprNode(&state);
			expr.type = ast.ExprType.CHR_LIT;
			goto end;
		case tokens.PTokenType.NUM_LIT:
			self.eat();
			expr = self.exprNode(&state);
			expr.type = ast.ExprType.NUM_LIT;
			goto end;
		default:
			break;
		}
		switch tok.sType {
		case tokens.STokenType.FUNC:
			return self.funcExpr();
		default:
			break;
		}
		tok.println();
		self.error("expected expr, got {tok}");
		
	label end:
		expr.buff = tok.buff; // skip spaces
		expr.len = tok.len;	
		return expr;
	};
	func exprOrType(self: *Parser) ast.TypeOrExpr {
		r := (ast.TypeOrExpr){};
		switch self.peek().pType {
		case tokens.PTokenType.LBRACE:
			r.type = ast.TypeExprEnum.TYPE;
			r.data.type = self.type();
			break;
		default:
			r.type = ast.TypeExprEnum.EXPR;
			r.data.expr = self.expr();
		}
		return r;
	};
	func callExpr(self: *Parser, function: *ast.Expr, statePtr: *ParserState) *ast.Expr {
		self.eat();
		c := (ast.CallExpr){function: function};

		if self.peek().pType == tokens.PTokenType.RPAREN {
			c.args = null;
		} else {
			c.args = self.exprVec();
			self.expectPri(tokens.PTokenType.RPAREN);
		}
		self.eat();
		
		e := self.exprNode(statePtr);
		e.type = ast.ExprType.CALL;
		e.data.callExpr = c;
		return e;
	};
	func newExpr(self: *Parser) *ast.Expr {
		state := self.state();
		newExpr := self.newExprRaw();

		expr := self.exprNode(&state);
		expr.type = ast.ExprType.NEW;
		expr.data.newExpr = newExpr;
		return expr;
	};
	func newExprRaw(self: *Parser) ast.NewExpr {
		self.eat();
		newExpr := (ast.NewExpr){};
		
		if self.peek().pType == tokens.PTokenType.LPAREN {
			newExpr.type = null;
			newExpr.val = self.expr();
			return newExpr;
		}
		newExpr.type = self.type();

		if self.peek().pType == tokens.PTokenType.LPAREN {
			newExpr.val = self.expr();
		}
		return newExpr;
	};
	func awaitExpr(self: *Parser) *ast.Expr {
		state := self.state();
		self.eat();
		
		e := self.expr();

		expr := self.exprNode(&state);
		expr.type = ast.ExprType.AWAIT;
		expr.data.awaitExpr = (ast.AwaitExpr){expr: e};
		return expr;
	};
	func sizeExpr(self: *Parser) *ast.Expr {
		state := self.state();
		self.eat();
		self.expectPri(tokens.PTokenType.LPAREN);
		self.eat();

		e := self.expr();

		self.expectPri(tokens.PTokenType.RPAREN);
		self.eat();

		expr := self.exprNode(&state);
		expr.type = ast.ExprType.SIZEOF;
		expr.data.sizeExpr = (ast.SizeExpr){expr: e};
		return expr;
	};
	func castExpr(self: *Parser) *ast.Expr {
		state := self.state();
		self.eat();
		self.expectPri(tokens.PTokenType.LPAREN);
		self.eat();

		type := self.type();

		self.expectPri(tokens.PTokenType.RPAREN);
		self.eat();

		e := self.expr9();
		expr := self.exprNode(&state);
		expr.type = ast.ExprType.CAST;
		expr.data.castExpr = (ast.CastExpr){expr: e, type: type};
		return expr;
	};
	func genCallExpr(self: *Parser, e: *ast.Expr, statePtr: *ParserState) *ast.Expr {
		self.eat();
		g := (ast.GenCall){expr: e};

		if self.peek().pType == tokens.PTokenType.LPAREN {
			self.eat();
			g.types = self.typeVec();

			self.expectPri(tokens.PTokenType.RPAREN);
			self.eat();
		} else {
			g.types = (vec *ast.Type){self.type()};
		}

		expr := self.exprNode(statePtr);
		expr.type = ast.ExprType.GENCALL;
		expr.data.genCall = g;
		return expr;
	};
	func arrayInitializer(self: *Parser) *ast.Expr {
		state := self.state();
		self.eat();

		elements := self.exprVec();
		self.expectPri(tokens.PTokenType.LCBRACE);
		self.eat();

		expr := self.exprNode(&state);
		expr.type = ast.ExprType.ARRLIT;
		expr.data.arrayLit = (ast.ArrayLit){elements: cast(*void)elements};
		return expr;
	};
	func compLitData(self: *Parser, lit: *ast.CompLit) {
		self.eat();
		tok := self.peek();

		if tok.pType == tokens.PTokenType.RCBRACE {
			self.eat();
			lit.fields = null;
			lit.values = null;
			return;
		}

		e := self.expr();

		if t := self.peek(); e.type != ast.ExprType.IDENT || t.sType != tokens.STokenType.COLON {
			lit.fields = null;
			lit.values = (vec *ast.Expr){};
			lit.values.push(e);

			if t.pType == tokens.PTokenType.RCBRACE {
				self.eat();
				return;
			}
			self.expectSec(tokens.STokenType.COMMA);
			self.eat();

			exprs := self.exprVec();
			lit.values.concat(exprs);

			exprs.free();
			goto end;
		}
		delete e;
		
		lit.fields = (vec ast.IdentExpr){};
		lit.values = (vec *ast.Expr){};

		lit.fields.push((ast.IdentExpr){tok: tok});
		self.expectSec(tokens.STokenType.COLON);
		self.eat();
		lit.values.push(self.expr());

		for self.peek().sType == tokens.STokenType.COMMA {
			self.eat();

			lit.fields.push((ast.IdentExpr){tok: self.expectPri(tokens.PTokenType.IDENT)});
			self.eat();
			self.expectSec(tokens.STokenType.COLON);
			self.eat();
			lit.values.push(self.expr());
		}

	label end:
		self.expectPri(tokens.PTokenType.RCBRACE);
		self.eat();
	};
	func funcExpr(self: *Parser) *ast.Expr {
		state := self.state();
		function := self.funcExprRaw();

		expr := self.exprNode(&state);
		expr.type = ast.ExprType.FUNC;
		expr.data.funcExpr = function;
		return expr;
	};
	func funcExprRaw(self: *Parser) ast.FuncExpr {
		self.eat();

		function := (ast.FuncExpr){};
		function.type = new ast.FuncType;
		function.type.args.names = (vec ast.IdentExpr){};
		function.type.args.types = (vec *ast.Type){};
		function.type.varargs = null;

		tok := self.peek();

		switch tok.sType {
		case tokens.STokenType.WORK:
			function.type.type = ast.FuncTypeEnum.WORK;
			self.eat();
			break;
		case tokens.STokenType.ASYNC:
			function.type.type = ast.FuncTypeEnum.ASYNC;
			self.eat();
			break;
		default:
			function.type.type = ast.FuncTypeEnum.ORD;
			break;
		}

		self.expectPri(tokens.PTokenType.LPAREN);
		self.eat();
		
		if self.peek().pType != tokens.PTokenType.RPAREN {
			goto body;
		} else {
			goto next;
		}

		for self.peek().sType == tokens.STokenType.COMMA {
			self.eat();

		label body:
			if tok := self.peek(); tok.pType == tokens.PTokenType.IDENT {
				function.type.args.names.push((ast.IdentExpr){tok: tok});
				self.eat();
				self.expectSec(tokens.STokenType.COLON);
				self.eat();
				function.type.args.types.push(self.type());
			} else if tok.sType == tokens.STokenType.DOTDOT {
				self.eat();
				function.type.varargs = new ast.IdentExpr{tok: self.expectPri(tokens.PTokenType.IDENT)};
				self.eat();
				break;
			} else {
				self.error("bruhhh");
			}
		}
		self.expectPri(tokens.PTokenType.RPAREN);

	label next:
		self.eat();

		if self.peek().pType != tokens.PTokenType.LCBRACE {
			function.type.returnType = self.type();
		} else {
			function.type.returnType = null;
		}
		function.body = self.blockRaw();
		return function;
	};
	func swtchExpr(self: *Parser) *ast.Expr {
		state := self.state();
		swtch := self.swtchExprRaw();

		expr := self.exprNode(&state);
		expr.type = ast.ExprType.SWITCH;
		expr.data.swtch = swtch;
		return expr;
	};
	func swtchExprRaw(self: *Parser) ast.SwitchExpr {
		self.eat();		
		swtch := (ast.SwitchExpr){conds: (vec *ast.Expr){}, vals: (vec *ast.Expr){}};
		
		if stmt := self.basicStmt(); self.peek().pType == tokens.PTokenType.LCBRACE {
			self.assert(stmt.type == ast.StmtType.EXPR, "bruh gib expression, not type");
			swtch.initStmt = null;
			swtch.expr = stmt.data.expr.expr;
			delete stmt;
		} else {
			swtch.initStmt = stmt;
			self.expectPri(tokens.PTokenType.SEMICOLON);
			self.eat();
			swtch.expr = self.expr();
			self.expectPri(tokens.PTokenType.LCBRACE);
		}
		self.eat();

		for s := self.peek().sType;; s = self.peek().sType {
			switch s {
			case tokens.STokenType.CASE:
				self.eat();
				swtch.conds.push(self.expr());
				self.expectSec(tokens.STokenType.COLON);
				self.eat();
				swtch.vals.push(self.expr());
				break;
			case tokens.STokenType.DEFAULT:
				self.eat();
				self.expectSec(tokens.STokenType.COLON);
				self.eat();
				swtch.defalt = self.expr();
				break;
			default:
				goto out;
			}
			self.expectPri(tokens.PTokenType.SEMICOLON);
			self.eat();
		}

	label out:
		self.expectPri(tokens.PTokenType.RCBRACE);
		self.eat();
		return swtch;
	};
	func mtchExpr(self: *Parser) *ast.Expr {
		state := self.state();
		mtch := self.mtchExprRaw();
		
		expr := self.exprNode(&state);
		expr.type = ast.ExprType.MATCH;
		expr.data.mtch = mtch;
		return expr;
	};
	func mtchExprRaw(self: *Parser) ast.MatchExpr {
		self.eat();
		mtch := (ast.MatchExpr){conds: (vec *ast.Pattern){}, vals: (vec *ast.Expr){}};
		
		if stmt := self.basicStmt(); self.peek().pType == tokens.PTokenType.LCBRACE {
			self.assert(stmt.type == ast.StmtType.EXPR, "bruh gib expression, not type");
			mtch.initStmt = null;
			mtch.expr = stmt.data.expr.expr;
			delete stmt;
		} else {
			mtch.initStmt = stmt;
			self.expectPri(tokens.PTokenType.SEMICOLON);
			self.eat();
			mtch.expr = self.expr();
			self.expectPri(tokens.PTokenType.LCBRACE);
		}
		self.eat();

		for s := self.peek().sType;; s = self.peek().sType {
			switch s {
			case tokens.STokenType.CASE:
				self.eat();
				mtch.conds.push(self.pattern());
				self.expectSec(tokens.STokenType.COLON);
				self.eat();
				mtch.vals.push(self.expr());
				break;
			case tokens.STokenType.DEFAULT:
				self.eat();
				self.expectSec(tokens.STokenType.COLON);
				self.eat();
				mtch.defalt = self.expr();
				break;
			default:
				goto out;
			}
			self.expectPri(tokens.PTokenType.SEMICOLON);
			self.eat();
		}

	label out:
		self.expectPri(tokens.PTokenType.RCBRACE);
		self.eat();
		return mtch;
	};
	func genricExpr(self: *Parser) *ast.Expr {
		state := self.state();
		genric := self.genricExprRaw();

		expr := self.exprNode(&state);
		expr.type = ast.ExprType.GENERIC;
		expr.data.genric = genric;
		return expr;
	};
	func genricExprRaw(self: *Parser) ast.GenericExpr {
		self.eat();		
		genric := (ast.GenericExpr){conds: (vec *ast.Expr){}, vals: (vec *ast.Expr){}};
		
		genric.type = self.type();
		self.expectPri(tokens.PTokenType.LCBRACE);
		self.eat();

		for s := self.peek().sType;; s = self.peek().sType {
			switch s {
			case tokens.STokenType.CASE:
				self.eat();
				genric.conds.push(self.type());
				self.expectSec(tokens.STokenType.COLON);
				self.eat();
				genric.vals.push(self.expr());
				break;
			case tokens.STokenType.DEFAULT:
				self.eat();
				self.expectSec(tokens.STokenType.COLON);
				self.eat();
				genric.defalt = self.expr();
				break;
			default:
				goto out;
			}
			self.expectPri(tokens.PTokenType.SEMICOLON);
			self.eat();
		}

	label out:
		self.expectPri(tokens.PTokenType.RCBRACE);
		self.eat();
		return genric;
	};
	func type(self: *Parser) *ast.Type { // array
		state := self.state();
		
		if self.peek().pType != tokens.PTokenType.LBRACE {
			return self.type1();
		}
		
		self.eat();
		type: *ast.Type;

		if self.peek().pType != tokens.PTokenType.RBRACE {
			size := new ast.BasicLit{self.expectPri(tokens.PTokenType.NUM_LIT)};
			self.eat();
			self.expectPri(tokens.PTokenType.RBRACE);
			self.eat();

			base := self.type();
			type = self.typeNode(&state);
			type.type = ast.TypeType.ARRAY;
			type.data.array = (ast.ArrayType){base: base, size: size};
		} else {
			self.eat();
			base := self.type();
			type = self.typeNode(&state);
			type.type = ast.TypeType.IMPARRAY;
			type.data.impArray = (ast.ImpArrayType){base: base};
		}
		return type;
	};
	func type1(self: *Parser) *ast.Type { // pointer
		state := self.state();

		if self.peek().sType != tokens.STokenType.MUL {
			return self.type2();
		}
		
		self.eat();
		base := self.type();

		type := self.typeNode(&state);
		type.type = ast.TypeType.POINTER;
		type.data.pointer = (ast.PointerType){base: base};
		return type;
	};
	func type2(self: *Parser) *ast.Type { // const, capture, promise, vec keywords
		type: *ast.Type;
		state := self.state();
		t: *ast.Type;

		switch self.peek().sType {
		case tokens.STokenType.VEC:
			self.eat();
			t = self.type();
			type = self.typeNode(&state);
			type.type = ast.TypeType.VECTOR;
			type.data.vector = (ast.VectorType){base: t};
			break;
		case tokens.STokenType.CONST:
			self.eat();
			t = self.type();
			type = self.typeNode(&state);
			type.type = ast.TypeType.CONST;
			type.data.cnst = (ast.ConstType){base: t};
			break;
		case tokens.STokenType.PROMISE:
			self.eat();
			t = self.type();
			type = self.typeNode(&state);
			type.type = ast.TypeType.PROMISE;
			type.data.promse = (ast.PromiseType){base: t};
			break;
		default:
			return self.type3();
		}
		return type;
	};
	func type3(self: *Parser) *ast.Type { // function, struct, tuple, enum, parenthesis, basic, expr type
		tok := self.peek();
		
		switch tok.sType {
		case tokens.STokenType.FUNC:
			return self.funcType();
		case tokens.STokenType.STRUCT:
			return self.structType();
		case tokens.STokenType.UNION:
			return self.unionType();
		case tokens.STokenType.TUPLE:
			return self.tupleType();
		case tokens.STokenType.ENUM:
			return self.enumType();
		default:
			break;
		}
		switch tok.pType {
		case tokens.PTokenType.LPAREN: {
			self.eat();
			t := self.type();
			self.expectPri(tokens.PTokenType.RPAREN);
			self.eat();
			return t;
		}
		case tokens.PTokenType.TYPE: {
			state := self.state();
			self.eat();

			t := self.typeNode(&state);
			t.type = ast.TypeType.BASIC;
			t.buff = tok.buff;
			t.len = tok.len;
			return t;
		}
		default:
			break;
		}
		state := self.state();
		expr := self.expr12();

		if self.peek().sType == tokens.STokenType.LNOT {
			return self.genCallType(expr, &state);
		}

		type := self.typeNode(&state);
		type.type = ast.TypeType.EXPR;
		type.data.expr = (ast.BasicExprType){expr};
		return type;
	};
	func genCallType(self: *Parser, e: *ast.Expr, statePtr: *ParserState) *ast.Type {
		self.eat();
		g := (ast.GenCall){expr: e};

		if self.peek().pType == tokens.PTokenType.LPAREN {
			self.eat();
			g.types = self.typeVec();

			self.expectPri(tokens.PTokenType.RPAREN);
			self.eat();
		} else {
			g.types = (vec *ast.Type){self.type()};
		}

		type := self.typeNode(statePtr);
		type.type = ast.TypeType.GENCALL;
		type.data.genCall = g;
		return type;
	};
	func funcType(self: *Parser) *ast.Type {
		state := self.state();
		self.eat();
		fnc := self.funcTypeRaw();

		type := self.typeNode(&state);
		type.type = ast.TypeType.FUNC;
		type.data.fnc = fnc;
		return type;
	};
	func funcTypeRaw(self: *Parser) ast.FuncType {
		t := (ast.FuncType){};
		tok := self.peek();

		switch tok.sType {
		case tokens.STokenType.WORK:
			t.type = ast.FuncTypeEnum.WORK;
			self.eat();
			break;
		case tokens.STokenType.ASYNC:
			t.type = ast.FuncTypeEnum.ASYNC;
			self.eat();
			break;
		case tokens.STokenType.NATIVE:
			t.type = ast.FuncTypeEnum.NATIVE;
			self.eat();
			break;
		default:
			t.type = ast.FuncTypeEnum.NATIVE;
			break;
		}
		self.expectPri(tokens.PTokenType.LPAREN);
		self.eat();
		
		t.args.names = null;
		t.args.types = (vec *ast.Type){};
		
		if self.peek().pType != tokens.PTokenType.RPAREN {
			goto body;
		} else {
			goto next;
		}
		for self.peek().pType != tokens.PTokenType.RPAREN {
			self.expectSec(tokens.STokenType.COMMA);
			self.eat();
		label body:
			if tok := self.peek(); tok.sType == tokens.STokenType.DOTDOT {
				self.eat();
				t.varargs = cast(*void)1;
				break;
			} else {
				t.args.types.push(self.type());
			}
		}

	label next:
		self.eat();
		if tok := self.peek();
			tok.sType != tokens.STokenType.COMMA	 &&
			tok.pType != tokens.PTokenType.SEMICOLON &&
			tok.pType != tokens.PTokenType.RPAREN	 &&
			tok.pType != tokens.PTokenType.LCBRACE {
			t.returnType = self.type();
		} else {
			t.returnType = null;
		}
		return t;
	};
	func structTypedef(self: *Parser) *ast.Stmt {
		state := self.state();
		tdef := self.structTypedefRaw();

		stmt := self.stmtNode(&state);
		stmt.type = ast.StmtType.TYPEDEF;
		stmt.data.tdef = tdef;
		return stmt;
	};
	func structTypedefRaw(self: *Parser) ast.Typedef {
		self.eat();
		name := new ast.IdentExpr{self.expectPri(tokens.PTokenType.IDENT)};
		self.eat();

		type := self.structBody();

		type.data.strct.name = name;
		return (ast.Typedef){name: name, type: type};
	};
	func structType(self: *Parser) *ast.Type {
		state := self.state();
		self.eat();
		strct := self.structBodyRaw();
		
		type := self.typeNode(&state);
		type.type = ast.TypeType.STRUCT;
		type.data.strct = strct;
		return type;
	};
	func structBody(self: *Parser) *ast.Type {
		state := self.state();
		strct := self.structBodyRaw();
		
		type := self.typeNode(&state);
		type.type = ast.TypeType.STRUCT;
		type.data.strct = strct;

		return type;
	};
	func structBodyRaw(self: *Parser) ast.StructType {
		self.expectPri(tokens.PTokenType.LCBRACE);
		self.eat();
		
		strct := (ast.StructType){};
		strct.name = null;
		strct.props = (ast.StructPropSOA){idents: (vec ast.IdentExpr){}, types: (vec *ast.Type){}};
		strct.methods = (ast.StructMethodSOA){idents: (vec ast.IdentExpr){}, types: (vec ast.FuncType){}, blocks: (vec ast.Block){}};
		strct.tmplates = (ast.StructTemplateMethodSOA){idents: (vec ast.IdentExpr){}, types: (vec ast.TemplateType){}};
		strct.superStructs = (vec *ast.Expr){};

		for tok := self.peek(); tok.pType != tokens.PTokenType.RCBRACE; tok = self.peek() {
			switch tok := self.peek(); tok.sType {
			case tokens.STokenType.DOTDOT:
				self.eat();
				strct.superStructs.push(self.expr());
				break;
			case tokens.STokenType.FUNC:
				self.structMethod(strct);
				break;
			case tokens.STokenType.TEMPLATE:
				self.structTemplate(strct);
				break;
			default:
				self.structProp(strct);
				break;
			}
			self.expectPri(tokens.PTokenType.SEMICOLON);
			self.eat();
		}
		self.eat();
		return strct;
	};
	func structTemplate(self: *Parser, strct: ast.StructType){
		state := self.state();
		t := self.tmplateRaw();
		
		type := self.typeNode(&state);
		type.type = ast.TypeType.TEMPLATE;
		type.data.tmplate = t.type;

		strct.tmplates.idents.push(*t.name);
		strct.tmplates.types.push(type);

		delete t.name;
	};
	func structMethod(self: *Parser, strct: ast.StructType){
		state := self.state();
		f := self.funcDecRawNoBlock();

		type := self.typeNode(&state);
		type.type = ast.TypeType.FUNC;
		type.data.fnc = f.type;

		strct.methods.idents.push(*f.name);
		strct.methods.types.push(type);
		strct.methods.blocks.push(self.blockRaw());

		delete f.name;
	};
	func structProp(self: *Parser, strct: ast.StructType){
		i := 0;
		goto loop1;

		for self.peek().sType == tokens.STokenType.COMMA {
			self.eat();
		label loop1:
			strct.props.idents.push((ast.IdentExpr){tok: self.expectPri(tokens.PTokenType.IDENT)});
			self.eat();
			++i;
		}
		self.expectSec(tokens.STokenType.COLON);
		self.eat();
		
		j := 0;
		t := self.type();
		goto loop2;
		
		for self.peek().sType == tokens.STokenType.COMMA {
			self.eat();
			t = self.type();
		label loop2:
			strct.props.types.push(t);
			++j;
		}
		if j != 1 && i != j {
			self.error("invalid number of types in struct prop");
		}
		for j < i {
			strct.props.types.push(t);
			++j;
		}
	};
	func enumTypedef(self: *Parser) *ast.Stmt {
		state := self.state();
		tdef := self.enumTypedefRaw();

		stmt := self.stmtNode(&state);
		stmt.type = ast.StmtType.TYPEDEF;
		stmt.data.tdef = tdef;
		return stmt;
	};
	func enumTypedefRaw(self: *Parser) ast.Typedef {
		self.eat();
		name := new ast.IdentExpr{self.expectPri(tokens.PTokenType.IDENT)};
		self.eat();

		type := self.enumBody();
		return (ast.Typedef){name: name, type: type};
	};
	func enumType(self: *Parser) *ast.Type {
		state := self.state();
		self.eat();
		enm := self.enumBodyRaw();
		
		type := self.typeNode(&state);
		type.type = ast.TypeType.ENUM;
		type.data.enm = enm;
		return type;
	};
	func enumBody(self: *Parser) *ast.Type {
		state := self.state();
		enm := self.enumBodyRaw();
		
		type := self.typeNode(&state);
		type.type = ast.TypeType.ENUM;
		type.data.enm = enm;
		return type;
	};
	func enumBodyRaw(self: *Parser) ast.EnumType {
		self.expectPri(tokens.PTokenType.LCBRACE);
		self.eat();

		enm := (ast.EnumType){idents: (vec ast.IdentExpr){}, values: (vec *ast.Expr){}};
		
	label body:
		enm.idents.push((ast.IdentExpr){self.expectPri(tokens.PTokenType.IDENT)});
		self.eat();

		if self.peek().sType == tokens.STokenType.EQ {
			self.eat();
			enm.values.push(self.expr());
		} else {
			enm.values.push(null);
		}
		if self.peek().sType == tokens.STokenType.COMMA {
			self.eat();
			goto body;
		}
		self.expectPri(tokens.PTokenType.RCBRACE);
		self.eat();
		return enm;
	};
	func unionTypedef(self: *Parser) *ast.Stmt {
		state := self.state();
		tdef := self.unionTypedefRaw();

		stmt := self.stmtNode(&state);
		stmt.type = ast.StmtType.TYPEDEF;
		stmt.data.tdef = tdef;
		return stmt;
	};
	func unionTypedefRaw(self: *Parser) ast.Typedef {
		self.eat();
		name := new ast.IdentExpr{self.expectPri(tokens.PTokenType.IDENT)};
		self.eat();
		
		type := self.unionBody();
		return (ast.Typedef){name: name, type: type};
	};
	func unionType(self: *Parser) *ast.Type {
		state := self.state();
		self.eat();
		unon := self.unionBodyRaw();
		
		type := self.typeNode(&state);
		type.type = ast.TypeType.UNION;
		type.data.unon = unon;
		return type;
	};
	func unionBody(self: *Parser) *ast.Type {
		state := self.state();
		unon := self.unionBodyRaw();
		
		type := self.typeNode(&state);
		type.type = ast.TypeType.UNION;
		type.data.unon = unon;
		return type;
	};
	func unionBodyRaw(self: *Parser) ast.UnionType {
		self.expectPri(tokens.PTokenType.LCBRACE);
		self.eat();
		unon := (ast.UnionType){decs: (vec ast.Declaration){}};

		for self.peek().pType != tokens.PTokenType.RCBRACE {
			unon.decs.push(self.decNoVal());
			self.expectPri(tokens.PTokenType.SEMICOLON);
			self.eat();
		}
		self.eat();
		return unon;
	};
	func tupleTypedef(self: *Parser) *ast.Stmt {
		state := self.state();
		tdef := self.tupleTypedefRaw();

		stmt := self.stmtNode(&state);
		stmt.type = ast.StmtType.TYPEDEF;
		stmt.data.tdef = tdef;
		return stmt;
	};
	func tupleTypedefRaw(self: *Parser) ast.Typedef {
		self.eat();
		name := new ast.IdentExpr{self.expectPri(tokens.PTokenType.IDENT)};
		self.eat();
		
		type := self.tupleBody();
		return (ast.Typedef){name: name, type: type};
	};
	func tupleType(self: *Parser) *ast.Type {
		state := self.state();
		self.eat();
		tupl := self.tupleBodyRaw();
		
		type := self.typeNode(&state);
		type.type = ast.TypeType.TUPLE;
		type.data.tupl = tupl;
		return type;
	};
	func tupleBody(self: *Parser) *ast.Type {
		state := self.state();
		tupl := self.tupleBodyRaw();
		
		type := self.typeNode(&state);
		type.type = ast.TypeType.TUPLE;
		type.data.tupl = tupl;
		return type;
	};
	func tupleBodyRaw(self: *Parser) ast.TupleType {
		self.expectPri(tokens.PTokenType.LCBRACE);
		self.eat();

		tupl := (ast.TupleType){types: self.typeVec()};

		self.expectPri(tokens.PTokenType.RCBRACE);
		self.eat();
		return tupl;
	};
	func pattern(self: *Parser) *ast.Pattern {
		state := self.state();
		p := self.pattern1();

		for tok := self.peek(); tok.pType == tokens.PTokenType.LOGIC_OP; tok = self.peek() {
			self.eat();
			p2 := (ast.BinaryPattern){left: p, right: self.pattern1(), op: new ast.Operator{tok}};

			p = self.patternNode(&state);
			p.type = ast.PatternType.BINARY;
			p.data.binary = p2;
		}
		return p;
	};
	func pattern1(self: *Parser) *ast.Pattern {
		state, tok := self.state(), self.peek();
		pattern: *ast.Pattern;

		data := (ast.PatternUnion){};

		switch tok.sType {
		case tokens.STokenType.DOTDOT:
			return self.elRange(&state);
		default:
			break;
		}
		switch tok.pType {
		case tokens.PTokenType.LPAREN:
			return self.rangeP(&state);
		case tokens.PTokenType.LBRACE:
			return self.rangeB(&state);
		case tokens.PTokenType.LCBRACE:
			return self.compPattern(&state);
		case tokens.PTokenType.RELAT_OP:
			self.eat();
			data.unary = (ast.UnaryPattern){op: new ast.Operator{tok}, expr: self.expr2()};
			pattern = self.patternNode(&state);
			pattern.type = ast.PatternType.UNARY;
			pattern.data = data;
			return pattern;
		default:
			data.expr = (ast.ExprPattern){expr: self.expr2()};
			pattern = self.patternNode(&state);
			pattern.type = ast.PatternType.EXPR;
			pattern.data = data;
			return pattern;
		}

		return null;
	};
	func compPattern(self: *Parser, statePtr: *ParserState) *ast.Pattern {
		self.eat();
		comp := (ast.CompPattern){};
		
		tok := self.peek();
		e := self.pattern();

		if t := self.peek(); e.type != ast.PatternType.EXPR || (cast(*ast.ExprPattern)&e.data.expr).expr.type != ast.ExprType.IDENT || t.sType != tokens.STokenType.COLON {
			comp.fields = null;
			comp.values = (vec *ast.Pattern){};
			comp.values.push(e);

			if t.pType == tokens.PTokenType.RCBRACE {
				self.eat();
				goto end;
			}
			self.expectSec(tokens.STokenType.COMMA);
			self.eat();

			ps := self.patternVec();
			comp.values.concat(ps);

			ps.free();
			
			self.expectPri(tokens.PTokenType.RCBRACE);
			self.eat();
			goto end;
		}
		delete e;
		
		comp.fields = (vec ast.IdentExpr){};
		comp.values = (vec *ast.Pattern){};

		comp.fields.push((ast.IdentExpr){tok: tok});
		self.expectSec(tokens.STokenType.COLON);
		self.eat();
		comp.values.push(self.pattern());

		for self.peek().sType == tokens.STokenType.COMMA {
			self.eat();

			comp.fields.push((ast.IdentExpr){tok: self.expectPri(tokens.PTokenType.IDENT)});
			self.eat();
			self.expectSec(tokens.STokenType.COLON);
			self.eat();
			comp.values.push(self.pattern());
		}

		self.expectPri(tokens.PTokenType.RCBRACE);
		self.eat();
	
	label end:
		pattern := self.patternNode(statePtr);
		pattern.type = ast.PatternType.COMP;
		pattern.data.comp = comp;
		
		return pattern;
	};
	func rangeP(self: *Parser, statePtr: *ParserState) *ast.Pattern {
		self.eat();
		p := (ast.RangePattern){};

		if self.peek().sType == tokens.STokenType.COLON {
			self.eat();
			p.left = null;
			p.right = self.expr();
			goto next;
		}
		p.left = self.expr();

		if self.peek().pType == tokens.PTokenType.LPAREN {
			pattern := self.patternNode(statePtr);
			pattern.type = ast.PatternType.EXPR;
			pattern.data.expr = (ast.ExprPattern){expr: p.left};
			return pattern;
		}
		self.expectSec(tokens.STokenType.COLON);
		self.eat();

		if t := self.peek().pType; t == tokens.PTokenType.RPAREN || t == tokens.PTokenType.RBRACE {
			self.eat();
			p.type = ast.RangeType.NONE;
			p.right = null;
			goto end;
		}
		p.right = self.expr();
	
	label next:
		switch self.peek().pType {
		case tokens.PTokenType.RPAREN:
			p.type = ast.RangeType.NONE;
			break;
		case tokens.PTokenType.RBRACE:
			p.type = ast.RangeType.RIGHT;
			break;
		default:
			self.error("bruh gib paren or brace");
			break;
		}
		self.eat();
	
	label end:
		pattern := self.patternNode(statePtr);
		pattern.type = ast.PatternType.RANGE;
		pattern.data.range = p;
		return pattern;
	};
	func rangeB(self: *Parser, statePtr: *ParserState) *ast.Pattern {
		self.eat();
		p := (ast.RangePattern){};

		if self.peek().sType == tokens.STokenType.COLON {
			self.eat();
			goto next;
		} 
		p.left = self.expr();

		self.expectSec(tokens.STokenType.COLON);
		self.eat();

		if t := self.peek().pType; t == tokens.PTokenType.RPAREN || t == tokens.PTokenType.RBRACE {
			self.eat();
			p.type = ast.RangeType.LEFT;
			p.right = null;
			goto end;
		}
		p.right = self.expr();

	label next:
		switch self.peek().pType {
		case tokens.PTokenType.RPAREN:
			p.type = ast.RangeType.LEFT;
			break;
		case tokens.PTokenType.RBRACE:
			p.type = ast.RangeType.BOTH;
			break;
		default:
			self.error("bruh gib paren or brace");
			break;
		}
		self.eat();
	
	label end:
		pattern := self.patternNode(statePtr);
		pattern.type = ast.PatternType.RANGE;
		pattern.data.range = p;
		return pattern;
	};
	func elRange(self: *Parser, statePtr: *ParserState) *ast.Pattern {
		self.eat();
		
		elRange := (ast.ElementRangePattern){len: self.expr()};
		
		if self.peek().sType != tokens.STokenType.EQ {
			elRange.val = null;
			goto end;
		}
		self.eat();

		if self.peek().sType == tokens.STokenType.DOTDOT {
			elRange.dotdot = true;
			self.eat();
			elRange.val = self.pattern();
			self.assert(elRange.val.type == ast.PatternType.EXPR, "gib expr, not pattern smh");
		} else {
			elRange.dotdot = false;
			elRange.val = self.pattern();
		}

	label end:
		pattern := self.patternNode(statePtr);
		pattern.type = ast.PatternType.ELRANGE;
		pattern.data.elRange = elRange;
		return pattern;
	};
};
export func NewParser(l: lexer.Lexer) Parser {
	return (Parser){
		lexer:   l, 
		context: NewParserContext(),
	};
};
