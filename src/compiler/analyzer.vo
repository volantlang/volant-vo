import "io.vo";
import "mem.vo";
import "heap.vo";

import "tokens.vo";
import "lexer.vo";
import "names.vo";
import "ast.vo";
import "parser.vo";
import "deepcopy.vo";
import "symbols.vo";
import "compiler.vo";
import "importer.vo";

BoolType := &(ast.Type){
	type: ast.TypeType.BASIC,
	buff: "bool",
	len: 4,
};
SizeType := &(ast.Type){
	type: ast.TypeType.BASIC,
	buff: "size_t",
	len: 6,
};
struct AnalyzerContextData {
	found: bool;
	index: u16;
};

struct AnalyzerContext {
	data:       AnalyzerContextData;
	stack:      vec *ast.Stmt;
	allowTypes: bool;
};

export func NewAnalyzerContext() AnalyzerContext {
	return (AnalyzerContext){
		stack:      (vec *ast.Stmt){},
		data:       (AnalyzerContextData){found: false},
		allowTypes: false
	};
};

export struct Buff {
	buff: *i8;
	len: size_t;
};

export struct Analyzer {
	path:    Buff;
	context: AnalyzerContext;
	symbols: *symbols.SymbolTable;
	top:     *symbols.SymbolTable;

	imports:        vec *Analyzer;
	importNames:    vec *ast.IdentExpr;
	unnamedImports: vec *Analyzer;

	exports:   *symbols.SymbolTable;
	namespace: names.NameSpace;
	heap:      vec *void;
	typeId:    u64;

	func error(self: *Analyzer, msg: *i8){
		io.println(msg);
		$exit(1);
	};
	func pushScope(self: *Analyzer){
		self.symbols = self.symbols.newChild();
	};
	func popScope(self: *Analyzer){
		self.symbols = self.symbols.parent;
	};
	func assert(self: *Analyzer, cond: bool, msg: *i8){
		if cond {
			return;
		} else {
			self.error(msg);
		}
	};
	func addVar(self: *Analyzer, name: *i8, len: size_t, type: *ast.Type){
		if self.symbols.getVarInCurr(name, len) == null {
			self.symbols.addVar(name, len, type);
		} else {
			io.printnln(name, len);
			self.error("{name} already defined.");
		}
	};
	func addType(self: *Analyzer, name: *i8, len: size_t, type: *ast.Type){
		if self.symbols.getTypeInCurr(name, len) == null && self.symbols.getVar(name, len) == null && self.symbols.getLabel(name, len) == false {
			self.symbols.addType(name, len, type);
		} else {
			self.error("{name} already defined.");
		}
	};
	func addLabel(self: *Analyzer, name: *i8, len: size_t){
		if self.symbols.getLabel(name, len) == false {
			self.symbols.addLabel(name, len);
		} else {
			self.error("{name} already defined.");
		}
	};
	func getVar(self: *Analyzer, name: *i8, len: size_t) *ast.Type {
		if v := self.symbols.getVar(name, len); v != null {
			return v;
		} else if self.symbols.getType(name, len) != null {
			if self.context.allowTypes == true {
				return null;
			}
			self.error("{name} is a type, not a variable.");
		} else if self.symbols.getLabel(name, len) != false {
			self.error("{name} is a label, not a variable.");
		} else {
			// self.error("{name} variable not defined.");
		}
		return null;
	};
	func getVarNoError(self: *Analyzer, name: *i8, len: size_t) *ast.Type {
		if v := self.symbols.getVar(name, len); v != null {
			return v;
		}
		return null;
	};
	func getExportedVarNoError(self: *Analyzer, name: *i8, len: size_t) *ast.Type {
		if v := self.exports.getVar(name, len); v != null {
			return v;
		}
		return null;
	};
	func getType(self: *Analyzer, name: *i8, len: size_t) *ast.Type {
		if v := self.symbols.getType(name, len); v != null {
			return v;
		} else if self.symbols.getVar(name, len) != null {
			self.error("{name} is a variable, not a type.");
		} else if self.symbols.getLabel(name, len) != false {
			self.error("{name} is a label, not a type.");
		} else {
			io.printnln(name, len);
			self.error("{name} type not defined.");
		}
		return null;
	};
	func getTypeNoError(self: *Analyzer, name: *i8, len: size_t) *ast.Type {
		if v := self.symbols.getType(name, len); v != null {
			return v;
		}
		return null;
	};
	func getTypeIndex(self: *Analyzer, name: *i8, len: size_t) i32 {
		i := self.top.getTypeIndexInCurr(name, len);

		if i == -1 {
			self.error("{name} type not defined");
		}
		return i;
	};
	func getTypeIndexNoError(self: *Analyzer, name: *i8, len: size_t) i32 {
		return self.top.getTypeIndexInCurr(name, len);
	};
	func getTypeFromIndex(self: *Analyzer, i: size_t) *ast.Type {
		return self.top.types.types[i];
	};
	func getImplFromIndex(self: *Analyzer, i: size_t) ast.ImplData {
		return self.top.types.impls[i];
	};
	func getExportedTypeNoError(self: *Analyzer, name: *i8, len: size_t) *ast.Type {
		if v := self.exports.getType(name, len); v != null {
			return v;
		}
		return null;
	};
	func getLabel(self: *Analyzer, name: *i8, len: size_t) bool {
		if v := self.symbols.getLabel(name, len); v != false {
			return v;
		} else if self.symbols.getVar(name, len) != null {
			self.error("{name} is a var, not a label.");
		} else if self.symbols.getType(name, len) != null {
			self.error("{name} is a type, not a label.");
		} else {
			self.error("{name} label not defined.");
		}
		return false;
	};
	func getImportContext(self: *Analyzer, expr: *ast.Expr) *Analyzer {
		for i := 0; i < self.importNames.length; ++i {
			tok := self.importNames[i].tok;
			if tok.len == expr.len && mem.compare(tok.buff, expr.buff, expr.len) == 0 {
				return self.imports[i];
			}
		}
		return null;
	};
	func var(self: *Analyzer, n: *names.NameInfo){
		n.index = self.namespace;
		n.type = names.NameType.VAR;
	};
	func ident(self: *Analyzer, ident: *ast.IdentExpr){
		self.var(&ident.name);
	};
	func identVec(self: *Analyzer, idents: *void){
		identVec := cast(vec ast.IdentExpr)idents;

		for i := 0; i < identVec.length; ++i {
			self.ident(&identVec[i]);
		}
	};
	func preImports(self: *Analyzer, file: ast.File) ast.File {
		i: i32;
		file.namespace = self.namespace;

		for i = 0; i < file.___cs.length; ++i {
			self.___c(file.___cs[i]);
		}
		for i = 0; i < file.tdefs.length; ++i {
			s := file.tdefs[i];
			tdef := *cast(*ast.Typedef)(&s.stmt.data.tdef);
			self.addType(tdef.name.tok.buff, tdef.name.tok.len, tdef.type);

			if s.exported == true {
				self.exports.addType(tdef.name.tok.buff, tdef.name.tok.len, tdef.type);
			}
		}
		for i = 0; i < file.impls.length; ++i {
			s := file.impls[i];
			self.impll1(s.data.impll);
		}
		for i = 0; i < file.funcs.length; ++i {
			s := file.funcs[i];
			fnc := *cast(*ast.FuncDec)(&s.stmt.data.funcDec);
			self.addVar(fnc.name.tok.buff, fnc.name.tok.len, fnc.type);

			if s.exported == true {
				self.exports.addVar(fnc.name.tok.buff, fnc.name.tok.len, fnc.type);
			}
		}
		for i = 0; i < file.tmplates.length; ++i {
			s := file.tmplates[i];
			tmplate := *cast(*ast.Template)(&s.stmt.data.tmplate);

			self.tmplate(tmplate);

			if s.exported == false {
				continue;
			}
			switch tmplate.type.data.tmplate.type {
			case ast.TypeExprEnum.TYPE:
				self.exports.addType(tmplate.name.tok.buff, tmplate.name.tok.len, tmplate.type);
				break;
			case ast.TypeExprEnum.EXPR:
				self.exports.addVar(tmplate.name.tok.buff, tmplate.name.tok.len, tmplate.type);
				break;
			}
		}
		return file;
	};
	func imports_(self: *Analyzer, file: ast.File) {
		for i: i32 = 0; i < file.imprts.length; ++i {
			s := file.imprts[i];
			self.imprt(s.data.imprt);
		}
	};
	func postImports(self: *Analyzer, file: ast.File) {
		i: i32;
		for i = 0; i < file.tdefs.length; ++i {
			s := file.tdefs[i];
			self.tdefNoAdd(s.stmt.data.tdef);
		}
		for i = 0; i < file.decs.length; ++i {
			s := file.decs[i];
			self.dec(s.stmt.data.dec);
		}
		for i = 0; i < file.impls.length; ++i {
			s := file.impls[i];
			self.impll2(s.data.impll);
		}
		for i = 0; i < file.funcs.length; ++i {
			s := file.funcs[i];
			self.funcDecNoAdd(s.stmt.data.funcDec);
		}
	};
	func globalStmt(self: *Analyzer, stmt: *ast.Stmt){
		switch stmt.type {
		case ast.StmtType.FUNC:
			self.funcDec(stmt.data.funcDec);
			break;
		case ast.StmtType.DEC:
			self.dec(stmt.data.dec);
			break;
		case ast.StmtType.TEMPLATE:
			self.tmplate(stmt.data.tmplate);
			break;
		case ast.StmtType.TYPEDEF:
			self.tdef(stmt.data.tdef);
			break;
		case ast.StmtType.__C:
			self.___c(stmt);
			break;
		case ast.StmtType.IMPORT:
			self.imprt(stmt.data.imprt);
			break;
		default:
			break;
		}
	};
	func localStmt(self: *Analyzer, stmt: *ast.Stmt){
		switch stmt.type {
		case ast.StmtType.DEC:
			self.dec(stmt.data.dec);
			break;
		case ast.StmtType.FUNC:
			self.funcDec(stmt.data.funcDec);
			break;
		case ast.StmtType.EXPR:
			self.expr(stmt.data.expr.expr);
			break;
		case ast.StmtType.ASSIGN:
			self.assign(stmt);
			break;
		case ast.StmtType.IF_ELSE:
			self.ifElse(stmt);
			break;
		case ast.StmtType.LOOP:
			self.loop(stmt);
			break;
		case ast.StmtType.SWITCH:
			self.swtch(stmt);
			break;
		case ast.StmtType.MATCH:
			self.mtch(stmt);
			break;
		case ast.StmtType.RETURN:
			self.rturn(stmt);
			break;
		case ast.StmtType.GENERIC:
			self.genric(stmt);
			break;
		case ast.StmtType.GCASE:
			self.genericCase(stmt);
			break;
		case ast.StmtType.SCASE:
			self.switchCase(stmt);
			break;
		case ast.StmtType.MCASE:
			self.matchCase(stmt);
			break;
		case ast.StmtType.__C:
			self.___c(stmt);
			break;
		case ast.StmtType.DEFAULT:
			self.defalt(stmt);
			break;
		case ast.StmtType.DELETE:
			self.del(stmt);
			break;
		default:
			break;
		}
	};
	func imprt(self: *Analyzer, imprt: ast.Import){
		a: *Analyzer;

		path: *i8;
		len: size_t;

		if a = importer.search(self.path.buff, self.path.len, imprt.path.tok.buff+1, imprt.path.tok.len-2, &path, &len); a != null {
			goto next;
		}

		s := symbols.NewSymbolTable(null);
		a = new Analyzer{
			symbols:        s,
			top:            s,
			heap:           (vec *void){},
			namespace:      importer.getNextNameSpace(),

			context:        NewAnalyzerContext(),
			exports:        symbols.NewSymbolTable(null),

			imports:        (vec *Analyzer){},
			importNames:    (vec *ast.IdentExpr){},
			unnamedImports: (vec *Analyzer){}
		};
		data := importer.read(self.path.buff, self.path.len, imprt.path.tok.buff+1, imprt.path.tok.len-2, &path, &len);

		if data == null {
			self.error("Couldnt import file");
			return;
		}
		a.path.buff = path;
		a.path.len = len;

		importer.compile(data, path, cast(*func(*void, ast.File) ast.File)(&a.preImports), cast(*func(*void, ast.File))(&a.imports_), cast(*func(*void, ast.File))(&a.postImports), cast(*void)a);
		goto nextNext;

	label next:
		a.path.buff = path;
		a.path.len = len;

	label nextNext:
		if imprt.name != null {
			self.importNames.push(imprt.name);
			self.imports.push(a);
		} else {
			self.unnamedImports.push(a);
		}
	};
	func del(self: *Analyzer, stmt: *ast.Stmt){
		del := *cast(*ast.Delete)(&stmt.data.del);
		self.exprVec(del.exprs);
	};
	func ___c(self: *Analyzer, stmt: *ast.Stmt){
		x := self.context.allowTypes;
		self.context.allowTypes = true;

		self.exprVec(stmt.data.___c.stuff);
		self.context.allowTypes = x;
	};
	func blockNoScope(self: *Analyzer, block: ast.Block){
		for i := 0; i < block.stmts.length; ++i {
			self.localStmt(block.stmts[i]);
		}
	};
	func block(self: *Analyzer, block: ast.Block){
		self.pushScope();
		self.blockNoScope(block);
		self.popScope();
	};
	func tdefNoAdd(self: *Analyzer, tdef: ast.Typedef){
		self.ident(tdef.name);
		self.type(tdef.type);
	};
	func tdef(self: *Analyzer, tdef: ast.Typedef){
		self.tdefNoAdd(tdef);
		self.addType(tdef.name.tok.buff, tdef.name.tok.len, tdef.type);
	};
	func impll1(self: *Analyzer, impll: ast.Impl){
		self.assert(impll.type.type == ast.TypeType.EXPR, "aa");

		e := cast(*ast.Expr)impll.type.data.expr.expr;
		i := self.getTypeIndex(e.buff, e.len);

		if self.symbols.updateImpl(i, impll.data) == null {
			io.println("aaaaaaaaa");
		}
	};
	func impll2(self: *Analyzer, impll: ast.Impl){
		for i := 0; i < impll.data.methods.length; ++i {
			self.funcDecNoAdd(impll.data.methods[i].data.funcDec);
		}
	};
	func decNoAdd(self: *Analyzer, dec: ast.Declaration){
		l1 := dec.idents.length;
		l2 := dec.types.length;

		if dec.values == null {
			goto next;
		}
		l3 := dec.values.length;

		if l3 == 1 {
			v := dec.values[0];
			self.expr(v);

			for dec.values.length != dec.idents.length {
				dec.values.push(v);
			}
		} else {
			for i := 0; i < l3; ++i {
				self.expr(dec.values[i]);
			}
		}
	label next:
		if l2 == 1 {
			t := dec.types[0];
			self.type(t);

			for dec.types.length != dec.idents.length {
				dec.types.push(t);
			}
		} else if l2 == 0 {
			for i := 0; i < dec.values.length; ++i {
				dec.types.push(dec.values[i].eType);
			}
		} else {
			for i := 0; i < dec.types.length; ++i {
				self.type(dec.types[i]);
			}
		}
		if dec.types.length != l1 {
			self.error("expected {l1} types, got {l2}.");
		} else if dec.values != null && dec.values.length != l1 {
			self.error("expected {l1} values, got {l3}.");
		}
	};
	func dec(self: *Analyzer, dec: ast.Declaration){
		self.decNoAdd(dec);

		for i, ident := 0, dec.idents[0]; i < dec.idents.length; ident = dec.idents[++i] {
			self.var(cast(*names.NameInfo)(&ident.data.name));
			self.addVar(ident.buff, ident.len, dec.types[i]);
		}
	};
	func funcDecNoBlockNoAddNoScope(self: *Analyzer, fnc: ast.FuncDec){
		self.ident(fnc.name);
		self.funcType(fnc.type.data.fnc);
	};
	func funcDecNoBlockNoScope(self: *Analyzer, fnc: ast.FuncDec){
		self.addVar(fnc.name.tok.buff, fnc.name.tok.len, fnc.type);
		self.funcDecNoBlockNoAddNoScope(fnc);
	};
	func funcDecNoAddNoScope(self: *Analyzer, fnc: ast.FuncDec){
		self.funcDecNoBlockNoAddNoScope(fnc);
		self.block(fnc.body);
	};
	func funcDecNoScope(self: *Analyzer, fnc: ast.FuncDec){
		self.funcDecNoBlockNoScope(fnc);
		self.blockNoScope(fnc.body);
	};
	func funcDecNoBlockNoAdd(self: *Analyzer, fnc: ast.FuncDec){
		self.pushScope();
		self.ident(fnc.name);
		self.funcType(fnc.type.data.fnc);
		self.popScope();
	};
	func funcDecNoBlock(self: *Analyzer, fnc: ast.FuncDec){
		self.addVar(fnc.name.tok.buff, fnc.name.tok.len, fnc.type);
		self.pushScope();
		self.funcDecNoBlockNoAdd(fnc);
		self.popScope();
	};
	func funcDecNoAdd(self: *Analyzer, fnc: ast.FuncDec){
		self.pushScope();
		self.funcDecNoBlockNoAddNoScope(fnc);
		self.block(fnc.body);
		self.popScope();
	};
	func funcDec(self: *Analyzer, fnc: ast.FuncDec){
		self.addVar(fnc.name.tok.buff, fnc.name.tok.len, fnc.type);
		self.pushScope();
		self.funcDecNoBlockNoAddNoScope(fnc);
		self.blockNoScope(fnc.body);
		self.popScope();
	};
	func assign(self: *Analyzer, stmt: *ast.Stmt){
		assign := *cast(*ast.Assignment)(&stmt.data.assign);

		self.assert(assign.vars.length == assign.vals.length, "Expected {assign.vars.length} values, got {assign.vals.length}");
		for i := 0; i < assign.vars.length; ++i {
			self.expr(assign.vars[i]);
			self.expr(assign.vals[i]);
			// self.assert(self.compareTypes(assign.vars[i].eType, assign.vals[i].eType), "Type mismatch in assignment");
		}
	};
	func ifElse(self: *Analyzer, stmt: *ast.Stmt){
		ifElse := *cast(*ast.IfElse)(&stmt.data.ifElse);
		s: *ast.Stmt;

		self.pushScope();
		for i := 0; i < ifElse.conds.length; ++i {
			s = ifElse.initStmts[i];

			if s != null {
				self.localStmt(s);
			}
			self.expr(ifElse.conds[i]);
			self.block(ifElse.blocks[i]);
		}
		if ifElse.elseBlock.stmts != null {
			self.block(ifElse.elseBlock);
		}
		self.popScope();
	};
	func loop(self: *Analyzer, stmt: *ast.Stmt){
		loop := *cast(*ast.Loop)(&stmt.data.loop);

		self.pushScope();
		if loop.initStmt != null {
			self.localStmt(loop.initStmt);
		}
		if loop.cond != null {
			self.expr(loop.cond);
		}
		if loop.loopStmt != null {
			self.localStmt(loop.loopStmt);
		}
		self.block(loop.block);
		self.popScope();
	};
	func swtch(self: *Analyzer, stmt: *ast.Stmt){
		self.context.stack.push(stmt);
		swtch := *cast(*ast.Switch)(&stmt.data.swtch);

		self.pushScope();
		if swtch.initStmt != null {
			self.localStmt(swtch.initStmt);
		}
		self.expr(swtch.expr);
		self.block(swtch.block);
		self.popScope();

		self.context.stack.pop();
	};
	func switchCase(self: *Analyzer, stmt: *ast.Stmt){
		self.expr(stmt.data.scase.val);
	};
	func mtch(self: *Analyzer, stmt: *ast.Stmt){
		self.context.stack.push(stmt);
		mtch := *cast(*ast.Match)(&stmt.data.mtch);

		self.pushScope();
		if mtch.initStmt != null {
			self.localStmt(mtch.initStmt);
		}
		self.expr(mtch.expr);
		self.block(mtch.block);
		self.popScope();

		self.context.stack.pop();
	};
	func matchCase(self: *Analyzer, stmt: *ast.Stmt){
		self.pattern(stmt.data.mcase.val);
	};
	func tmplateNoAdd(self: *Analyzer, tmplate: ast.Template){
		self.ident(tmplate.name);
		self.templateType(tmplate.type.data.tmplate);
	};
	func tmplate(self: *Analyzer, tmplate: ast.Template){
		self.tmplateNoAdd(tmplate);

		switch tmplate.type.data.tmplate.type {
		case ast.TypeExprEnum.TYPE:
			self.addType(tmplate.name.tok.buff, tmplate.name.tok.len, tmplate.type);
			break;
		case ast.TypeExprEnum.EXPR:
			self.addVar(tmplate.name.tok.buff, tmplate.name.tok.len, tmplate.type);
			break;
		default:
			break;
		}
	};
	func rturn(self: *Analyzer, stmt: *ast.Stmt){
		if val := cast(*ast.Expr)stmt.data.rturn.val; val != null {
			self.expr(val);
		}
	};
	func genric(self: *Analyzer, stmt: *ast.Stmt){
		self.context.stack.push(stmt);
		self.context.data.found = false;

		genric := *cast(*ast.Generic)(&stmt.data.genric);
		self.type(genric.type);

		s: *ast.Stmt;

		i := 0;
		for ; i < genric.block.stmts.length && self.context.data.found == false; ++i {
			self.context.data.index = i;
			self.localStmt(genric.block.stmts[i]);
		}
		for ; i < genric.block.stmts.length; ++i {
			self.context.data.index = i;

			switch s = genric.block.stmts[i]; s.type {
			case ast.StmtType.BREAK:
				stmt.data.genric.end = i;
				goto out;
			default:
				self.localStmt(s);
				break;
			}
		}
		self.error("gib a default case plz");
	label out:
		// $printf("%i, %i\n", stmt.data.genric.start, stmt.data.genric.end);
		self.context.stack.pop();
	};
	func genericCase(self: *Analyzer, stmt: *ast.Stmt){
		gcase := *cast(*ast.GenericCase)(&stmt.data.gcase);

		if self.context.data.found == true {
			stmt.type = ast.StmtType.NULL;
			delete gcase.val;
			return;
		}

		s := self.context.stack[self.context.stack.length-1];

		if self.compareTypes(s.data.genric.type, gcase.val) {
			s.data.genric.start = self.context.data.index;
			self.context.data.found = true;
		}
	};
	func defalt(self: *Analyzer, stmt: *ast.Stmt){
		s := self.context.stack[self.context.stack.length-1];

		if s.type == ast.StmtType.GENERIC {
			self.context.data.found = true;
			s.data.genric.start = self.context.data.index;
		}
	};
	func exprVec(self: *Analyzer, exprs: *void){
		exprVec := cast(vec *ast.Expr)exprs;
		for i := 0; i < exprVec.length; ++i {
			self.expr(exprVec[i]);
		}
	};
	func expr(self: *Analyzer, expr: *ast.Expr){
		switch expr.type {
		case ast.ExprType.IDENT:
			self.identExpr(expr);
			break;
		case ast.ExprType.UNARY:
			self.unaryExpr(expr);
			break;
		case ast.ExprType.PUNARY:
			self.punaryExpr(expr);
			break;
		case ast.ExprType.BINARY:
			self.binaryExpr(expr);
			break;
		case ast.ExprType.TERNARY:
			self.ternaryExpr(expr);
			break;
		case ast.ExprType.COMPLIT:
			self.compLit(expr);
			break;
		case ast.ExprType.ELEMENT:
			self.elementExpr(expr);
			break;
		case ast.ExprType.CAST:
			self.castExpr(expr);
			break;
		case ast.ExprType.NEW:
			self.newExpr(expr);
			break;
		case ast.ExprType.SIZEOF:
			self.sizeExpr(expr);
			break;
		case ast.ExprType.AWAIT:
			self.awaitExpr(expr);
			break;
		case ast.ExprType.CALL:
			self.callExpr(expr);
			break;
		case ast.ExprType.MEMBER:
			self.memberExpr(expr);
			break;
		case ast.ExprType.GENCALL:
			self.genCallExpr(expr);
			break;
		case ast.ExprType.FUNC:
			self.funcExpr(expr);
			break;
		case ast.ExprType.GENERIC:
			self.genricExpr(expr);
			break;
		case ast.ExprType.IS:
			self.isExpr(expr);
			break;
		case ast.ExprType.STMT:
			self.stmtExpr(expr);
			break;
		default:
			expr.eType = null;
			break;
		}
	};
	func identExpr(self: *Analyzer, expr: *ast.Expr){
		// io.println("here");	
		if t := self.getVarNoError(expr.buff, expr.len); t != null {
			self.var(&expr.data.name);
			expr.eType = t;
			return;
		}
		for i := 0; i < self.unnamedImports.length; ++i {
			an := self.unnamedImports[i];

			if t := an.getVarNoError(expr.buff, expr.len); t != null {
				an.var(&expr.data.name);
				expr.eType = t;
				return;
			}
		}
		self.var(&expr.data.name);
		// expr.print();
		// io.println(" is not defined");
	};
	func unaryExpr(self: *Analyzer, expr: *ast.Expr){
		e := cast(*ast.Expr)expr.data.unary.expr;
		self.expr(e);

		switch op := cast(*ast.Operator)expr.data.unary.op; op.tok.sType {
		case tokens.STokenType.MUL:
			expr.eType = e.eType.data.pointer.base;
			break;
		case tokens.STokenType.AND:
			expr.eType = self.pointerToType(e.eType);
			break;
		default:
			expr.eType = e.eType;
			break;
		}
	};
	func punaryExpr(self: *Analyzer, expr: *ast.Expr){
		e := cast(*ast.Expr)expr.data.unary.expr;
		self.expr(e);
		expr.eType = e.eType;
	};
	func binaryExpr(self: *Analyzer, expr: *ast.Expr){
		b := *cast(*ast.BinaryExpr)(&expr.data.binary);

		self.expr(b.left);
		self.expr(b.right);
	//	expr.println();
	//	b.left.eType.println();
	//	b.right.eType.println();

		self.assert(self.compareTypes(b.left.eType, b.right.eType), "Type mismatch, expected {b.left.eType}, got {b.right.eType}");

		switch b.op.tok.pType {
		case tokens.PTokenType.RELAT_OP:
			expr.eType = BoolType;
			break;
		default:
			expr.eType = b.left.eType;
			break;
		}
	};
	func ternaryExpr(self: *Analyzer, expr: *ast.Expr){
		e := cast(*ast.TernaryExpr)(&expr.data.ternary);

		self.expr(e.cond);
		self.expr(e.left);
		self.expr(e.right);

		self.assert(self.compareTypes(e.left.eType, e.right.eType), "Type mismatch: expected {e.left.eType}, got {e.right.eType}.");
		self.assert(self.compareTypes(e.cond.eType, BoolType) , "Type mismatch: expected bool, got {e.right.eType}.");

		expr.eType = e.left.eType;
	};
	func compLit(self: *Analyzer, expr: *ast.Expr){
		e := *cast(*ast.CompLit)&expr.data.compLit;
		vals := e.values;
		fields := e.fields;

		self.type(e.type);

		// handle field repetition here
		expr.eType = e.type;

		if vals == null {
			return;
		}
		for val, i := vals[0], 0; i < vals.length; val = vals[++i] {
			self.expr(val);
		}
		if fields == null {
			return;
		}
		for field, i := &fields[0], 0; i < fields.length; field = &fields[++i] {
			field.name.index = self.namespace;
			field.name.type = names.NameType.STRUCT_PROP;
		}
	};
	func elementExpr(self: *Analyzer, expr: *ast.Expr){
		e := (cast(*ast.ElementExpr)(&expr.data.element)).base;
		e2 := (cast(*ast.ElementExpr)(&expr.data.element)).index;

		self.expr(e);
		self.expr(e2);

		switch t := e.eType; t.type {
		case ast.TypeType.POINTER:
			expr.eType = cast(*ast.Type)t.data.pointer.base;
			break;
		case ast.TypeType.ARRAY:
			expr.eType = cast(*ast.Type)t.data.array.base;
			break;
		case ast.TypeType.VECTOR:
			expr.eType = cast(*ast.Type)t.data.vector.base;
			break;
		default:
			break;
		}
	};
	func castExpr(self: *Analyzer, expr: *ast.Expr){
		e := *cast(*ast.CastExpr)&expr.data.castExpr;
		type := e.type;
		exp := e.expr;

		self.expr(exp);
		self.type(type);

		// handle casting rules here
		expr.eType = type;
	};
	func newExpr(self: *Analyzer, expr: *ast.Expr){
		e := *cast(*ast.NewExpr)&expr.data.newExpr;
		type, val := e.type, e.val;

		if val != null {
			self.expr(val);
		}
		if type != null {
			self.type(type);
		} else if val != null {
			type, expr.data.newExpr.type = val.eType, val.eType;
		} else {
			self.error("bruh you baf");
		}
		expr.eType = self.pointerToType(type);
	};
	func sizeExpr(self: *Analyzer, expr: *ast.Expr){
		self.expr(expr.data.sizeExpr.expr);
		expr.eType = SizeType;
	};
	func awaitExpr(self: *Analyzer, expr: *ast.Expr){
		e := cast(*ast.Expr)expr.data.awaitExpr.expr;
		self.expr(e);
		self.assert(e.eType.type == ast.TypeType.PROMISE, "bruh");

		expr.eType = e.eType.data.promse.base;
	};
	func callExpr(self: *Analyzer, expr: *ast.Expr){
		call := *cast(*ast.CallExpr)(&expr.data.callExpr);
		fnc := call.function;
		self.expr(fnc);

		type := *cast(*ast.FuncType)(&fnc.eType.data.fnc);

		e := fnc;

		if e.type == ast.ExprType.GENCALL {
			e = e.data.genCall.expr;
		}
		if e.type != ast.ExprType.MEMBER {
			goto next;
		}
		e = e.data.member.base;
		t := e.eType;

		if type.args.types.length == 0 {
			goto end;
		}

		t2 := type.args.types[0];
		x: vec *ast.Expr;

		if self.compareTypes(t, t2) {
			x = (vec *ast.Expr){};
			x.push(e);
		} else if t.type == ast.TypeType.POINTER && self.compareTypes(t.data.pointer.base, t2) {
			x = (vec *ast.Expr){};
			x.push(self.dereference(e));
		} else if t2.type == ast.TypeType.POINTER && self.compareTypes(t, t2.data.pointer.base) {
			x = (vec *ast.Expr){};
			x.push(self.pointerToExpr(e));
		} else {
			goto next;
		}
		if call.args != null {
			x.concat(call.args);
			call.args.free();
		}
		expr.data.callExpr.args = x;

	label next:
		if cast(*void)expr.data.callExpr.args != null {
			self.exprVec(expr.data.callExpr.args);
		}
	label end:
		// temporary
		if fnc.eType != null {
			expr.eType = type.returnType;
		} else {
			fnc.println();
		}
	};
	func memberExpr(self: *Analyzer, expr: *ast.Expr){
		member := *cast(*ast.MemberExpr)(&expr.data.member);
		e := member.base;

		if e.type == ast.ExprType.IDENT {
			an := self.getImportContext(e);

			if an != null {
				expr.buff = member.prop.tok.buff;
				expr.len = member.prop.tok.len;
				expr.type = ast.ExprType.IDENT;

				an.expr(expr);
				return;
			}
		}
		self.expr(e);
		type := e.eType;

		if type.type == ast.TypeType.POINTER {
			type = type.data.pointer.base;
		}
		if type.type == ast.TypeType.GENCALL {
			genCall := *cast(*ast.GenCall)&type.data.genCall;
			tmplate := *cast(*ast.TemplateType)&genCall.expr.eType.data.tmplate;

			type = tmplate.datas[genCall.index].type;
		}
		prop := member.prop;

		if type.type != ast.TypeType.EXPR {
			goto next;
		}

		implData := *cast(*ast.ImplData)&type.data.expr.impls;

		if implData.methods == null {
			goto next1;
		}

		for i := 0; i < implData.methods.length; ++i {
			method := *cast(*ast.FuncDec)(&implData.methods[i].data.funcDec);

			if prop.tok.len == method.name.tok.len && mem.compare(method.name.tok.buff, prop.tok.buff, prop.tok.len) == 0 {
				expr.eType = implData.methods[i].data.funcDec.type;
				prop.name.type = names.NameType.METHOD;
				prop.name.index = (cast(*ast.IdentExpr)implData.methods[i].data.funcDec.name).name.index;
				return;
			}
		}

	label next1:
		type = self.getRootType(type);

	label next:
		if type.type != ast.TypeType.STRUCT {
			expr.println();
			self.error("meh");
		}
		strct := *cast(*ast.StructType)(&type.data.strct);

		i := self.getPropInfo(strct, prop.tok.buff, prop.tok.len);

		/*
		switch i.type.type {
		case ast.TypeType.TEMPLATE:
			prop.name.type = names.NameType.METHOD;
			break;
		case ast.TypeType.FUNC:
			if cast(ast.FuncTypeEnum2)i.type.data.fnc.type2 == ast.FuncTypeEnum2.NATIVE {
				prop.name.type = names.NameType.METHOD;
				break;
			}
		default:
		*/
		prop.name.type = names.NameType.STRUCT_PROP;
		//	break;
		// }
		prop.name.index = i.name;
		expr.eType = i.type;
		return;
	};
	func genCallExpr(self: *Analyzer, expr: *ast.Expr){
		e := cast(*ast.Expr)expr.data.genCall.expr;
		self.expr(e);

		tmplate := *cast(*ast.TemplateType)(&e.eType.data.tmplate);
		params := tmplate.params;
		args := tmplate.args;

		self.assert(tmplate.type == ast.TypeExprEnum.EXPR, "bruh genCallExpr()");
		types := cast(vec *ast.Type)expr.data.genCall.types;

		for i := 0; i < types.length; ++i {
			self.type(types[i]);
		}

		i := 0;
		for i < args.length && !self.compareTypeVec(args[i], types) { ++i; }

		expr.data.genCall.index = i;

		if i != args.length {
			return;
		}
		self.pushScope();

		for i := 0; i < types.length; ++i {
			t := types[i];
			t.labl = 1;
			self.addType(params[i].tok.buff, params[i].tok.len, t);
		}
		ee := deepcopy.copyExpr(tmplate.data.expr);

		args.push(cast(vec *ast.Type)expr.data.genCall.types);
		tmplate.datas.push((ast.TypeExprUnion){expr: ee});

		self.expr(ee);
		expr.eType = (ee).eType;
		self.popScope();
	};
	func funcExpr(self: *Analyzer, expr: *ast.Expr){
		fnc := cast(*ast.FuncExpr)(&expr.data.funcExpr);
		type := *cast(*ast.FuncType)(&fnc.type.data.fnc);

		names := type.args.names;
		types := type.args.types;

		self.pushScope();
		self.type(type.returnType);

		name: ast.IdentExpr;
		type2: *ast.Type;

		for i := 0; i < names.length; ++i {
			name = names[i];
			type2 = types[i];

			self.type(type2);
			self.var(&names[i].name);
			self.addVar(name.tok.buff, name.tok.len, type2);
		}
		self.block(fnc.body);
		self.popScope();

		expr.eType = fnc.type;
		self.heap.push(expr.eType);
	};
	func genricExpr(self: *Analyzer, expr: *ast.Expr){
		genric := *cast(*ast.GenericExpr)(&expr.data.genric);
		i := 0;
		for i < genric.conds.length && !self.compareTypes(genric.type, genric.conds[i]) { ++i; }
		expr.data.genric.index = i;
	};
	func isExpr(self: *Analyzer, expr: *ast.Expr){
		isExpr := *cast(*ast.IsExpr)&expr.data.isExpr;

		self.expr(isExpr.expr);
		self.pattern(isExpr.pattern);
	};
	func stmtExpr(self: *Analyzer, expr: *ast.Expr){
		stmts := cast(vec *ast.Stmt)expr.data.stmtExpr.stmts;

		self.pushScope();
		for i := 0; i < stmts.length; ++i {
			self.localStmt(stmts[i]);
		}
		self.popScope();
	};
	func genCallType(self: *Analyzer, type: *ast.Type){
		e := cast(*ast.Expr)type.data.genCall.expr;
		self.basicExprTypeExpr(e);

		tmplate := *cast(*ast.TemplateType)(&e.eType.data.tmplate);
		params := tmplate.params;
		args := tmplate.args;

		self.assert(tmplate.type == ast.TypeExprEnum.TYPE, "bruh genCallType()");
		types := cast(vec *ast.Type)type.data.genCall.types;

		i := 0;
		for i < args.length && !self.compareTypeVec(args[i], types) { ++i; }

		type.data.genCall.index = i;

		if i != args.length {
			return;
		}
		self.pushScope();

		for i := 0; i < types.length; ++i {
			t := types[i];
			t.labl = 1;
			self.addType(params[i].tok.buff, params[i].tok.len, t);
		}
		tt := deepcopy.copyType(tmplate.data.type);

		args.push(cast(vec *ast.Type)type.data.genCall.types);
		tmplate.datas.push((ast.TypeExprUnion){ type: tt });

		self.type(tt);
		self.popScope();
	};
	func normalizeType(self: *Analyzer, type: *ast.Type) *ast.Type {
		switch type.type {
		case ast.TypeType.CONST:
			return self.normalizeType(type.data.cnst.base);
		default:
			return type;
		}
	};
	func typeVec(self: *Analyzer, types: *void){
		typeVec := cast(vec *ast.Type)types;
		for i := 0; i < typeVec.length; ++i {
			self.type(typeVec[i]);
		}
	};
	func type(self: *Analyzer, type: *ast.Type){
		switch type.type {
		case ast.TypeType.EXPR:
			self.basicExprType(type);
			break;
		case ast.TypeType.GENCALL:
			self.genCallType(type);
			break;
		case ast.TypeType.POINTER:
			self.type(cast(*ast.Type)type.data.pointer.base);
			break;
		case ast.TypeType.ARRAY:
			self.type(cast(*ast.Type)type.data.array.base);
			break;
		case ast.TypeType.IMPARRAY:
			self.type(cast(*ast.Type)type.data.impArray.base);
			break;
		case ast.TypeType.STRUCT:
			self.structType(type.data.strct);
			break;
		case ast.TypeType.TEMPLATE:
			self.templateType(type.data.tmplate);
			break;
		case ast.TypeType.FUNC:
			self.funcType(type.data.fnc);
			break;
		default:
			break;
		}
	};
	func basicExprType(self: *Analyzer, type: *ast.Type){
		expr := cast(*ast.Expr)type.data.expr.expr;

		if expr.type == ast.ExprType.IDENT {
			i := self.getTypeIndexNoError(expr.buff, expr.len);

			if i != -1 {
				t := self.getTypeFromIndex(i);
				self.var(&expr.data.name);

				if t.labl == 0 {
					type.data.expr.impls = self.getImplFromIndex(i);
					expr.eType = t;
				} else {
					type.type = t.type;
					type.data = t.data;
					type.buff = t.buff;
					type.len = t.len;
					type.id = t.id;
				}
				// type.println();
				return;
			} else {
				// io.println("hehehhehehehehehhehehehehhe");
			}
			for i := 0; i < self.unnamedImports.length; ++i {
				an := self.unnamedImports[i];

				if t := an.getExportedTypeNoError(expr.buff, expr.len); t != null {
					an.var(&expr.data.name);
					expr.eType = t;
					return;
				}
			}
		} else if expr.type == ast.ExprType.MEMBER {
			an := self.getImportContext((cast(*ast.Expr)type.data.expr.expr).data.member.base);

			if an != null {
				e := cast(*ast.Expr)type.data.expr.expr;
				p := cast(*ast.IdentExpr)e.data.member.prop;

				e.buff = p.tok.buff;
				e.len = p.tok.len;
				e.type = ast.ExprType.IDENT;
				an.basicExprTypeExpr(e);
			}
		} else {
			self.error("Invalid type {type}");
		}
	};
	func basicExprTypeExpr(self: *Analyzer, expr: *ast.Expr){
		if expr.type == ast.ExprType.IDENT {
			t := self.getTypeNoError(expr.buff, expr.len);

			if t != null {
				expr.eType = t;
				self.var(&expr.data.name);
				return;
			}
			for i := 0; i < self.unnamedImports.length; ++i {
				an := self.unnamedImports[i];

				if t = an.getExportedTypeNoError(expr.buff, expr.len); t != null {
					an.var(&expr.data.name);
					expr.eType = t;
					return;
				}
			}
		}
	};
	func structType(self: *Analyzer, strct: ast.StructType){
		self.pushScope();
	/*
		for i := 0; i < strct.props.length; ++i {
			self.structProp1(strct.props[i]);
		}
		for i := 0; i < strct.props.length; ++i {
			self.structProp2(strct.props[i]);
		}
	*/
		for i := 0; i < strct.props.length; ++i {
			dec := *cast(*ast.Declaration)(&strct.props[i].data.dec);
			self.decNoAdd(dec);

			for i, ident := 0, dec.idents[0]; i < dec.idents.length; ident = dec.idents[++i] {
				self.addVar(ident.buff, ident.len, dec.types[i]);
				ident.data.name.index = self.namespace;
				ident.data.name.type = names.NameType.STRUCT_PROP;
			}
		}
		self.popScope();
	};
	func structProp1(self: *Analyzer, stmt: *ast.Stmt){
		switch stmt.type {
		case ast.StmtType.FUNC:
//			self.pushScope();
			self.funcDecNoBlockNoAdd(stmt.data.funcDec);
//			self.popScope();

			ident := cast(*ast.IdentExpr)stmt.data.funcDec.name;
			ident.name.index = self.namespace;
			ident.name.type = names.NameType.METHOD;
			break;
		case ast.StmtType.TEMPLATE:
			ident = stmt.data.tmplate.name;

			ident.name.index = self.namespace;
			ident.name.type = names.NameType.METHOD;
			break;
		default:
			null;
			dec := *cast(*ast.Declaration)(&stmt.data.dec);
			for i, ident := 0, dec.idents[0]; i < dec.idents.length; ident = dec.idents[++i] {
				ident.data.name.index = self.namespace;
				ident.data.name.type = names.NameType.STRUCT_PROP;
			}
			break;
		}
	};
	func structProp2(self: *Analyzer, stmt: *ast.Stmt){
		switch stmt.type {
		case ast.StmtType.FUNC:
			self.pushScope();
			self.funcDecNoAdd(stmt.data.funcDec);
			self.popScope();

			ident := cast(*ast.IdentExpr)stmt.data.funcDec.name;
			ident.name.index = self.namespace;
			ident.name.type = names.NameType.METHOD;
			break;
		case ast.StmtType.TEMPLATE:
			self.tmplateNoAdd(stmt.data.tmplate);

			ident = stmt.data.tmplate.name;
			ident.name.index = self.namespace;
			ident.name.type = names.NameType.METHOD;
			break;
		default:
			self.decNoAdd(stmt.data.dec);

			dec := *cast(*ast.Declaration)(&stmt.data.dec);
			for i, ident := 0, dec.idents[0]; i < dec.idents.length; ident = dec.idents[++i] {
				ident.data.name.index = self.namespace;
				ident.data.name.type = names.NameType.STRUCT_PROP;
			}
			break;
		}
	};
	func templateType(self: *Analyzer, tmplate: ast.TemplateType){
		for i := 0; i < tmplate.params.length; ++i {
			self.var(&tmplate.params[i].name);
		}
	};
	func funcType(self: *Analyzer, fnc: ast.FuncType){
		if fnc.returnType != null {
			self.type(fnc.returnType);
		}
		if fnc.args.names == null {
			self.typeVec(fnc.args.types);
		} else {
			ident: *ast.IdentExpr;
			type: *ast.Type;

			for i := 0; i < fnc.args.names.length; ++i {
				ident = &fnc.args.names[i];
				type = fnc.args.types[i];

				self.type(type);
				self.ident(ident);
				self.addVar(ident.tok.buff, ident.tok.len, type);
			}
		}
		if fnc.varargs != null && fnc.varargs != cast(*void)1 {
			self.ident(fnc.varargs);

			t := new ast.Type;
			t.type = ast.TypeType.EXPR;
			t.data.expr = (ast.BasicExprType){
				expr: new ast.Expr{
					type:   ast.ExprType.IDENT,
					buff:   "Arguments",
					len:    9,
					line:   fnc.varargs.tok.line,
					column: fnc.varargs.tok.column,
				}
			};
			self.heap.push(t);
			self.type(t);
			self.addVar(fnc.varargs.tok.buff, fnc.varargs.tok.len, t);
		}
	};
	func pattern(self: *Analyzer, pattern: *ast.Pattern){
		switch pattern.type {
		case ast.PatternType.EXPR:
			self.expr(pattern.data.expr.expr);
			break;
		case ast.PatternType.UNARY:
			self.expr(pattern.data.unary.expr);
			break;
		case ast.PatternType.BINARY:
			self.pattern(pattern.data.binary.left);
			self.pattern(pattern.data.binary.right);
			break;
		case ast.PatternType.COMP:
			self.compPattern(pattern);
			break;
		case ast.PatternType.ELRANGE:
			self.elRangePattern(pattern);
			break;
		case ast.PatternType.RANGE:
			self.rangePattern(pattern);
			break;
		};
	};
	func rangePattern(self: *Analyzer, pattern: *ast.Pattern){
		l := cast(*ast.Expr)pattern.data.range.left;
		r := cast(*ast.Expr)pattern.data.range.right;

		if l != null {
			self.expr(l);
		}
		if r != null {
			self.expr(r);
		}
	};
	func elRangePattern(self: *Analyzer, pattern: *ast.Pattern){
		self.expr(pattern.data.elRange.len);
		val := cast(*ast.Pattern)pattern.data.elRange.val;

		if val != null {
			self.pattern(val);
		}
	};
	func compPattern(self: *Analyzer, pattern: *ast.Pattern){
		vals := cast(vec *ast.Pattern)pattern.data.comp.values;
		fields := cast(vec ast.IdentExpr)pattern.data.comp.fields;

		for i := 0; i < vals.length; ++i {
			self.pattern(vals[i]);
		}
		if fields == null {
			return;
		}
		for i, ident := 0, fields[0]; i < fields.length; ident = fields[++i] {
			ident.name.index = self.namespace;
			ident.name.type = names.NameType.STRUCT_PROP;
		}
	};
	func pointerToType(self: *Analyzer, type: *ast.Type) *ast.Type {
		t := new ast.Type{
			type: ast.TypeType.POINTER,
			data: (ast.TypeUnion){pointer: (ast.PointerType){base: type}},
			id: 0
		};
		self.heap.push(t);
		return t;
	};
	func pointerToExpr(self: *Analyzer, expr: *ast.Expr) *ast.Expr {
		op := new ast.Operator{
			tok: (tokens.Token){ pType: tokens.PTokenType.BITW_OP, sType: tokens.STokenType.AND, buff: "&", len: 1}
		};
		e := new ast.Expr{
			type: ast.ExprType.UNARY,
			data: (ast.ExprUnion){unary: (ast.UnaryExpr){op: op, expr: expr}}
		};
		self.heap.push(op);
		self.heap.push(e);
		return e;
	};
	func dereference(self: *Analyzer, expr: *ast.Expr) *ast.Expr {
		op := new ast.Operator{
			tok: (tokens.Token){ pType: tokens.PTokenType.ARITH_OP, sType: tokens.STokenType.MUL, buff: "*", len: 1}
		};
		e := new ast.Expr{
			type: ast.ExprType.UNARY,
			data: (ast.ExprUnion){unary: (ast.UnaryExpr){op: op, expr: expr}}
		};
		self.heap.push(op);
		self.heap.push(e);
		return e;
	};
	func getPropInfo(self: *Analyzer, type: ast.StructType, buff: *i8, len: size_t) ast.NamespaceAndType {
		for i, l := 0, type.props.length; i < l; ++i {
			s := type.props[i];
		/*
			switch s.type {
			case ast.StmtType.FUNC:
				goto fnc;
			case ast.StmtType.TEMPLATE:
				goto tmplate;
			default:
				goto dec;
			}

		label fnc:
			ident := cast(*ast.IdentExpr)s.data.funcDec.name;
			if ident.tok.len != len || mem.compare(buff, ident.tok.buff, len) != 0 {
				continue;
			}
			return (ast.NamespaceAndType){name: ident.name.index, type: s.data.funcDec.type};
		label tmplate:
			ident = cast(*ast.IdentExpr)s.data.tmplate.name;
			if ident.tok.len != len || mem.compare(buff, ident.tok.buff, len) != 0 {
				continue;
			}
			return (ast.NamespaceAndType){name: ident.name.index, type: s.data.tmplate.type};
		label dec:
		*/
			dec := *cast(*ast.Declaration)(&s.data.dec);
			for x, ident := 0, dec.idents[0]; x < dec.idents.length; ident = dec.idents[++x] {
				if ident.len != len || mem.compare(buff, ident.buff, len) != 0 {
					continue;
				}
				return (ast.NamespaceAndType){name: ident.data.name.index, type: dec.types[x]};
			}
			continue;
		}
		return (ast.NamespaceAndType){name: 0, type: null};
	};
	func compareTypes(self: *Analyzer, type1: *ast.Type, type2: *ast.Type) bool {
		if type1 == type2 {
			return true;
		}
		if type1.id != 0 && type1.id == type2.id {
			return true;
		}
		if type1.type != type2.type {
			return false;
		}
		v: bool;

		switch type1.type {
		case ast.TypeType.BASIC:
			v = type1.len == type2.len && mem.compare(type1.buff, type2.buff, type1.len) == 0;
			break;
		case ast.TypeType.EXPR:
			v = (cast(*ast.Expr)type1.data.expr.expr).len == (cast(*ast.Expr)type2.data.expr.expr).len && mem.compare((cast(*ast.Expr)type1.data.expr.expr).buff, (cast(*ast.Expr)type2.data.expr.expr).buff, (cast(*ast.Expr)type1.data.expr.expr).len) == 0;
			break;
		case ast.TypeType.POINTER:
			v = self.compareTypes(type1.data.pointer.base, type2.data.pointer.base);
			break;
		case ast.TypeType.CONST:
			v = self.compareTypes(type1.data.cnst.base, type2.data.cnst.base);
			break;
		default:
			v = true;
		}

		if v {
			if type1.id != 0 {
				type2.id = type1.id;
			} else if type2.id != 0 {
				type1.id = type2.id;
			} else {
				type1.id = self.typeId;
				type2.id = self.typeId;
				++self.typeId;
			}
			return true;
		} else {
			//type1.id = self.typeId++;
			//type2.id = self.typeId++;
		}
		return false;
	};
	func compareTypeVec(self: *Analyzer, types1: *void, types2: *void) bool {
		typeVec1 := cast(vec *ast.Type)types1;
		typeVec2 := cast(vec *ast.Type)types2;

		if typeVec1.length != typeVec2.length {
			return false;
		}
		i := 0;

		for i < typeVec1.length && self.compareTypes(typeVec1[i], typeVec2[i]) { ++i; }
		return i == typeVec1.length;
	};
	func getRootType(self: *Analyzer, type: *ast.Type) *ast.Type {
		if type.type == ast.TypeType.EXPR {
			t := (cast(*ast.Expr)type.data.expr.expr).eType;
			return t != null ? t : type;
		}
		return type;
	};
};

export func NewAnalyzer(b: [6]i8, l: u16, path: *i8, len: size_t) Analyzer {
	s := symbols.NewSymbolTable(null);

	a := (Analyzer){
		path:           (Buff){buff: path, len: len},
		symbols:        s,
		top:            s,

		heap:           (vec *void){},
		namespace:      (names.NameSpace){len: l},
		context:        NewAnalyzerContext(),
		exports:        symbols.NewSymbolTable(null),

		imports:        (vec *Analyzer){},
		importNames:    (vec *ast.IdentExpr){},
		unnamedImports: (vec *Analyzer){},

		typeId: 1
	};
	mem.copy(a.namespace.buff, b, l);
	return a;
};
