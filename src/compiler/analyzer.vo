import "io.vo";
import "mem.vo";
import "heap.vo";

import "tokens.vo";
import "lexer.vo";
import "names.vo";
import "ast.vo";
import "parser.vo";
import "deepcopy.vo";
import "symbols.vo";
import "compiler.vo";
import "importer.vo";

BoolType := &(ast.Type){
	type: ast.TypeType.BASIC,
	buff: "bool",
	len: 4,
};
SizeType := &(ast.Type){
	type: ast.TypeType.BASIC,
	buff: "size_t",
	len: 6,
};
struct AnalyzerContextData {
	found: bool;
	index: u16;
};

struct AnalyzerContext {
	data:       AnalyzerContextData;
	stack:      vec *ast.Stmt;
	allowTypes: bool;
};

export func NewAnalyzerContext() AnalyzerContext {
	return (AnalyzerContext){
		stack:      (vec *ast.Stmt){},
		data:       (AnalyzerContextData){found: false},
		allowTypes: false
	};
};

export struct Analyzer {
	context: AnalyzerContext;
	symbols: *symbols.SymbolTable;

	imports:       vec *Analyzer;
	importNames:   vec *ast.IdentExpr;
	unamedImports: vec *Analyzer;

	exports: *symbols.SymbolTable;

	namespace: names.NameSpace;
	heap: vec *void;
	typeId: u64;

	func error(self: *Analyzer, msg: *i8){
		io.println(msg);
		$exit(1);
	};
	func pushScope(self: *Analyzer){
		self.symbols = self.symbols.newChild();
	};
	func popScope(self: *Analyzer){
		self.symbols = self.symbols.parent;
	};
	func assert(self: *Analyzer, cond: bool, msg: *i8){
		if cond {
			return;
		} else {
			self.error(msg);
		}
	};
	func addVar(self: *Analyzer, name: *i8, len: size_t, type: *ast.Type){
		if self.symbols.getVarInCurr(name, len) == null {
			self.symbols.addVar(name, len, type);
		} else {
			io.printnln(name, len);
			self.error("{name} already defined.");
		}
	};
	func addType(self: *Analyzer, name: *i8, len: size_t, type: *ast.Type){
		if self.symbols.getTypeInCurr(name, len) == null && self.symbols.getVar(name, len) == null && self.symbols.getLabel(name, len) == false {
			self.symbols.addType(name, len, type);
		} else {
			self.error("{name} already defined.");
		}
	};
	func addLabel(self: *Analyzer, name: *i8, len: size_t){
		if self.symbols.getLabel(name, len) == false {
			self.symbols.addLabel(name, len);
		} else {
			self.error("{name} already defined.");
		}
	};
	func getVar(self: *Analyzer, name: *i8, len: size_t) *ast.Type {
		if v := self.symbols.getVar(name, len); v != null {
			return v;
		} else if self.symbols.getType(name, len) != null {
			if self.context.allowTypes == true {
				return null;
			}
			self.error("{name} is a type, not a variable.");
		} else if self.symbols.getLabel(name, len) != false {
			self.error("{name} is a label, not a variable.");
		} else {
			// self.error("{name} variable not defined.");
		}
		return null;
	};
	func getType(self: *Analyzer, name: *i8, len: size_t) *ast.Type {
		if v := self.symbols.getType(name, len); v != null {
			return v;
		} else if self.symbols.getVar(name, len) != null {
			self.error("{name} is a variable, not a type.");
		} else if self.symbols.getLabel(name, len) != false {
			self.error("{name} is a label, not a type.");
		} else {
			io.printnln(name, len);
			self.error("{name} type not defined.");
		}
		return null;
	};
	func getLabel(self: *Analyzer, name: *i8, len: size_t) bool {
		if v := self.symbols.getLabel(name, len); v != false {
			return v;
		} else if self.symbols.getVar(name, len) != null {
			self.error("{name} is a var, not a label.");
		} else if self.symbols.getType(name, len) != null {
			self.error("{name} is a type, not a label.");
		} else {
			self.error("{name} label not defined.");
		}
		return false;
	};
	func getImportContext(self: *Analyzer, expr: *ast.Expr) *Analyzer {
		for i := 0; i < self.importNames.length; ++i {
			tok := self.importNames[i].tok;
			if tok.len == expr.len && mem.compare(tok.buff, expr.buff, expr.len) == 0 {
				return self.imports[i];
			}
		}
		return null;
	};
	func var(self: *Analyzer, n: *names.NameInfo){
		n.index = self.namespace;
		n.type = names.NameType.VAR;
	};
	func ident(self: *Analyzer, ident: *ast.IdentExpr){
		self.var(&ident.name);
	};
	func identVec(self: *Analyzer, idents: *void){
		identVec := cast(vec ast.IdentExpr)idents;
		for i := 0; i < identVec.length; ++i {
			self.ident(&identVec[i]);
		}
	};
	func file(self: *Analyzer, file: ast.File) ast.File {
		i: i32;
		for i = 0; i < file.___cs.length; ++i {
			self.___c(file.___cs[i]);
		}
		for i = 0; i < file.tdefs.length; ++i {
			s := file.tdefs[i];
			tdef := *cast(*ast.Typedef)(&s.stmt.data.tdef);
			self.addType(tdef.name.tok.buff, tdef.name.tok.len, tdef.type);
		}
		for i = 0; i < file.funcs.length; ++i {
			s := file.funcs[i];
			fnc := *cast(*ast.FuncDec)(&s.stmt.data.funcDec);
			self.addVar(fnc.name.tok.buff, fnc.name.tok.len, fnc.type);
		}
		for i = 0; i < file.tmplates.length; ++i {
			s := file.tmplates[i];
			self.tmplate(s.stmt.data.tmplate);
		}
		for i = 0; i < file.imprts.length; ++i {
			s := file.imprts[i];
			self.imprt(s.data.imprt);
		}
		for i = 0; i < file.tdefs.length; ++i {
			s := file.tdefs[i];
			self.tdefNoAdd(s.stmt.data.tdef);
		}
		for i = 0; i < file.decs.length; ++i {
			s := file.decs[i];
			self.dec(s.stmt.data.dec);
		}
		for i = 0; i < file.funcs.length; ++i {
			s := file.funcs[i];

			self.pushScope();
			self.funcDecNoAdd(s.stmt.data.funcDec);
			self.popScope();
		}
		return file;
	};
	func globalStmt(self: *Analyzer, stmt: *ast.Stmt){
		switch stmt.type {
		case ast.StmtType.FUNC:
			self.funcDec(stmt.data.funcDec);
			break;
		case ast.StmtType.DEC:
			self.dec(stmt.data.dec);
			break;
		case ast.StmtType.TEMPLATE:
			self.tmplate(stmt.data.tmplate);
			break;
		case ast.StmtType.TYPEDEF:
			self.tdef(stmt.data.tdef);
			break;
		case ast.StmtType.__C:
			self.___c(stmt);
			break;
		case ast.StmtType.IMPORT:
			self.imprt(stmt.data.imprt);
			break;
		default:
			break;
		}
	};
	func localStmt(self: *Analyzer, stmt: *ast.Stmt){
		switch stmt.type {
		case ast.StmtType.DEC:
			self.dec(stmt.data.dec);
			break;
		case ast.StmtType.FUNC:
			self.funcDec(stmt.data.funcDec);
			break;
		case ast.StmtType.EXPR:
			self.expr(stmt.data.expr.expr);
			break;
		case ast.StmtType.ASSIGN:
			self.assign(stmt);
			break;
		case ast.StmtType.IF_ELSE:
			self.ifElse(stmt);
			break;
		case ast.StmtType.LOOP:
			self.loop(stmt);
			break;
		case ast.StmtType.RETURN:
			self.rturn(stmt);
			break;
		case ast.StmtType.GENERIC:
			self.genric(stmt);
			break;
		case ast.StmtType.GCASE:
			self.genericCase(stmt);
			break;
		case ast.StmtType.__C:
			self.___c(stmt);
			break;
		case ast.StmtType.DEFAULT:
			self.defalt(stmt);
			break;
		case ast.StmtType.DELETE:
			self.del(stmt);
			break;
		default:
			break;
		}
	};
	func imprt(self: *Analyzer, imprt: ast.Import){
		path := cast(*i8)heap.malloc(imprt.path.tok.len);
		mem.copy(path, imprt.path.tok.buff+1, imprt.path.tok.len-2);

		path[imprt.path.tok.len-1] = 0;

		if a := importer.search(path); a != null {
			self.imports.push(a);
			return;
		}

		a := new Analyzer{
			symbols:     symbols.NewSymbolTable(null),
			heap:        (vec *void){},
			namespace:   importer.getNextNameSpace(),

			context:     NewAnalyzerContext(),
			exports:     symbols.NewSymbolTable(null),

			imports:     (vec *Analyzer){},
			importNames: (vec *ast.IdentExpr){}
		};
		r := importer.imprt(path, cast(* func (*void, ast.File) ast.File)(&a.file), a);

		if r == 1 {
			self.error("Couldnt import file");
		}
		self.importNames.push(imprt.name);
		self.imports.push(a);
	};
	func del(self: *Analyzer, stmt: *ast.Stmt){
		del := *cast(*ast.Delete)(&stmt.data.del);
		self.exprVec(del.exprs);
	};
	func ___c(self: *Analyzer, stmt: *ast.Stmt){
		x := self.context.allowTypes;
		self.context.allowTypes = true;

		self.exprVec(stmt.data.___c.stuff);
		self.context.allowTypes = x;
	};
	func blockNoScope(self: *Analyzer, block: ast.Block){
		for i := 0; i < block.stmts.length; ++i {
			self.localStmt(block.stmts[i]);
		}
	};
	func block(self: *Analyzer, block: ast.Block){
		self.pushScope();
		self.blockNoScope(block);
		self.popScope();
	};
	func tdefNoAdd(self: *Analyzer, tdef: ast.Typedef){
		self.ident(tdef.name);
		self.type(tdef.type);
	};
	func tdef(self: *Analyzer, tdef: ast.Typedef){
		self.tdefNoAdd(tdef);
		self.addType(tdef.name.tok.buff, tdef.name.tok.len, tdef.type);
	};
	func decNoAdd(self: *Analyzer, dec: ast.Declaration){
		l1 := dec.idents.length;
		l2 := dec.types.length;

		if dec.values == null {
			goto next;
		}
		if dec.values.length == 1 {
			v := dec.values[0];
			self.expr(v);
			for dec.values.length != dec.idents.length {
				dec.values.push(v);
			}
		} else {
			for i := 0; i < dec.values.length; ++i {
				self.expr(dec.values[i]);
			}
		}
	label next:
		if l2 == 1 {
			t := dec.types[0];
			self.type(t);
			for dec.types.length != dec.idents.length {
				dec.types.push(t);
			}
		} else if l2 == 0 {
			for i := 0; i < dec.values.length; ++i {
				dec.types.push(dec.values[i].eType);
			}
		} else {
			for i := 0; i < dec.types.length; ++i {
				self.type(dec.types[i]);
			}
		}
		if dec.types.length != l1 {
			self.error("expected {l1} types, got {l2}.");
		} else if dec.values != null && dec.values.length != l1 {
			self.error("expected {l1} values, got {l3}.");
		}
	};
	func dec(self: *Analyzer, dec: ast.Declaration){
		self.decNoAdd(dec);

		for i, ident := 0, dec.idents[0]; i < dec.idents.length; ident = dec.idents[++i] {
			self.var(cast(*names.NameInfo)(&ident.data.name));
			self.addVar(ident.buff, ident.len, dec.types[i]);
		}
	};
	func funcDecNoBlockNoAdd(self: *Analyzer, fnc: ast.FuncDec){
		self.ident(fnc.name);
		self.funcType(fnc.type.data.fnc);
	};
	func funcDecNoBlock(self: *Analyzer, fnc: ast.FuncDec){
		self.funcDecNoBlockNoAdd(fnc);
		self.addVar(fnc.name.tok.buff, fnc.name.tok.len, fnc.type);
	};
	func funcDecNoAdd(self: *Analyzer, fnc: ast.FuncDec){
		self.funcDecNoBlockNoAdd(fnc);
		self.block(fnc.body);
	};
	func funcDec(self: *Analyzer, fnc: ast.FuncDec){
		self.funcDecNoBlock(fnc);
		self.blockNoScope(fnc.body);
	};
	func assign(self: *Analyzer, stmt: *ast.Stmt){
		assign := *cast(*ast.Assignment)(&stmt.data.assign);

		self.assert(assign.vars.length == assign.vals.length, "Expected {assign.vars.length} values, got {assign.vals.length}");
		for i := 0; i < assign.vars.length; ++i {
			self.expr(assign.vars[i]);
			self.expr(assign.vals[i]);
			// self.assert(self.compareTypes(assign.vars[i].eType, assign.vals[i].eType), "Type mismatch in assignment");
		}
	};
	func ifElse(self: *Analyzer, stmt: *ast.Stmt){
		ifElse := *cast(*ast.IfElse)(&stmt.data.ifElse);
		s: *ast.Stmt;

		self.pushScope();
		for i := 0; i < ifElse.conds.length; ++i {
			s = ifElse.initStmts[i];

			if s != null {
				self.localStmt(s);
			}
			self.expr(ifElse.conds[i]);
			self.block(ifElse.blocks[i]);
		}
		if ifElse.elseBlock.stmts != null {
			self.block(ifElse.elseBlock);
		}
		self.popScope();
	};
	func loop(self: *Analyzer, stmt: *ast.Stmt){
		loop := *cast(*ast.Loop)(&stmt.data.loop);

		self.pushScope();
		if loop.initStmt != null {
			self.localStmt(loop.initStmt);
		}
		if loop.cond != null {
			self.expr(loop.cond);
		}
		if loop.loopStmt != null {
			self.localStmt(loop.loopStmt);
		}
		self.block(loop.block);
		self.popScope();
	};
	func tmplateNoAdd(self: *Analyzer, tmplate: ast.Template){
		self.ident(tmplate.name);
		self.templateType(tmplate.type.data.tmplate);
	};
	func tmplate(self: *Analyzer, tmplate: ast.Template){
		self.tmplateNoAdd(tmplate);

		switch tmplate.type.data.tmplate.type {
		case ast.TypeExprEnum.TYPE:
			self.addType(tmplate.name.tok.buff, tmplate.name.tok.len, tmplate.type);
			break;
		case ast.TypeExprEnum.EXPR:
			self.addVar(tmplate.name.tok.buff, tmplate.name.tok.len, tmplate.type);
			break;
		default:
			break;
		}
	};
	func rturn(self: *Analyzer, stmt: *ast.Stmt){
		if val := cast(*ast.Expr)stmt.data.rturn.val; val != null {
			self.expr(val);
		}
	};
	func genric(self: *Analyzer, stmt: *ast.Stmt){
		self.context.stack.push(stmt);
		self.context.data.found = false;

		genric := *cast(*ast.Generic)(&stmt.data.genric);
		self.type(genric.type);

		s: *ast.Stmt;

		i := 0;
		for ; i < genric.block.stmts.length && self.context.data.found == false; ++i {
			self.context.data.index = i;
			self.localStmt(genric.block.stmts[i]);
		}
		for ; i < genric.block.stmts.length; ++i {
			self.context.data.index = i;

			switch s = genric.block.stmts[i]; s.type {
			case ast.StmtType.BREAK:
				stmt.data.genric.end = i;
				goto out;
			default:
				self.localStmt(s);
				break;
			}
		}
		self.error("gib a default case plz");
	label out:
		// $printf("%i, %i\n", stmt.data.genric.start, stmt.data.genric.end);
		self.context.stack.pop();
	};
	func genericCase(self: *Analyzer, stmt: *ast.Stmt){
		gcase := *cast(*ast.GenericCase)(&stmt.data.gcase);

		if self.context.data.found == true {
			stmt.type = ast.StmtType.NULL;
			delete gcase.val;
			return;
		}

		s := self.context.stack[self.context.stack.length-1];

		if self.compareTypes(s.data.genric.type, gcase.val) {
			s.data.genric.start = self.context.data.index;
			self.context.data.found = true;
		}
	};
	func defalt(self: *Analyzer, stmt: *ast.Stmt){
		s := self.context.stack[self.context.stack.length-1];

		if s.type == ast.StmtType.GENERIC {
			self.context.data.found = true;
			s.data.genric.start = self.context.data.index;
		}
	};
	func exprVec(self: *Analyzer, exprs: *void){
		exprVec := cast(vec *ast.Expr)exprs;
		for i := 0; i < exprVec.length; ++i {
			self.expr(exprVec[i]);
		}
	};
	func expr(self: *Analyzer, expr: *ast.Expr){
		switch expr.type {
		case ast.ExprType.IDENT:
			self.var(&expr.data.name);
			expr.eType = self.getVar(expr.buff, expr.len);
			break;
		case ast.ExprType.UNARY:
			self.unaryExpr(expr);
			break;
		case ast.ExprType.PUNARY:
			self.punaryExpr(expr);
			break;
		case ast.ExprType.BINARY:
			self.binaryExpr(expr);
			break;
		case ast.ExprType.TERNARY:
			self.ternaryExpr(expr);
			break;
		case ast.ExprType.COMPLIT:
			self.compLit(expr);
			break;
		case ast.ExprType.ELEMENT:
			self.elementExpr(expr);
			break;
		case ast.ExprType.CAST:
			self.castExpr(expr);
			break;
		case ast.ExprType.NEW:
			self.newExpr(expr);
			break;
		case ast.ExprType.SIZEOF:
			self.sizeExpr(expr);
			break;
		case ast.ExprType.AWAIT:
			self.awaitExpr(expr);
			break;
		case ast.ExprType.CALL:
			self.callExpr(expr);
			break;
		case ast.ExprType.MEMBER:
			self.memberExpr(expr);
			break;
		case ast.ExprType.GENCALL:
			self.genCallExpr(expr);
			break;
		case ast.ExprType.FUNC:
			self.funcExpr(expr);
			break;
		case ast.ExprType.GENERIC:
			self.genricExpr(expr);
			break;
		default:
			expr.eType = null;
			break;
		}
	};
	func unaryExpr(self: *Analyzer, expr: *ast.Expr){
		e := cast(*ast.Expr)expr.data.unary.expr;
		self.expr(e);

		switch op := cast(*ast.Operator)expr.data.unary.op; op.tok.sType {
		case tokens.STokenType.MUL:
			expr.eType = e.eType.data.pointer.base;
			break;
		case tokens.STokenType.AND:
			expr.eType = self.pointerToType(e.eType);
			break;
		default:
			expr.eType = e.eType;
			break;
		}
	};
	func punaryExpr(self: *Analyzer, expr: *ast.Expr){
		e := cast(*ast.Expr)expr.data.unary.expr;
		self.expr(e);
		expr.eType = e.eType;
	};
	func binaryExpr(self: *Analyzer, expr: *ast.Expr){
		b := *cast(*ast.BinaryExpr)(&expr.data.binary);

		self.expr(b.left);
		self.expr(b.right);
		// self.assert(self.compareTypes(b.left.eType, b.right.eType), "Type mismatch, expected {a.left.eType}, got {b.right.eType}");

		switch b.op.tok.pType {
		case tokens.PTokenType.RELAT_OP:
			expr.eType = BoolType;
			break;
		default:
			expr.eType = b.left.eType;
			break;
		}
	};
	func ternaryExpr(self: *Analyzer, expr: *ast.Expr){
		e := cast(*ast.TernaryExpr)(&expr.data.ternary);

		self.expr(e.cond);
		self.expr(e.left);
		self.expr(e.right);

		self.assert(self.compareTypes(e.left.eType, e.right.eType), "Type mismatch: expected {e.left.eType}, got {e.right.eType}.");
		self.assert(self.compareTypes(e.cond.eType, BoolType) , "Type mismatch: expected bool, got {e.right.eType}.");

		expr.eType = e.left.eType;
	};
	func compLit(self: *Analyzer, expr: *ast.Expr){
		e := *cast(*ast.CompLit)&expr.data.compLit;
		vals := e.values;
		fields := e.fields;

		self.type(e.type);

		// handle field repetition here
		expr.eType = e.type;

		if vals == null {
			return;
		}
		for val, i := vals[0], 0; i < vals.length; val = vals[++i] {
			self.expr(val);
		}
		if fields == null {
			return;
		}
		for field, i := &fields[0], 0; i < fields.length; field = &fields[++i] {
			field.name.index = self.namespace;
			field.name.type = names.NameType.STRUCT_PROP;
		}
	};
	func elementExpr(self: *Analyzer, expr: *ast.Expr){
		e := (cast(*ast.ElementExpr)(&expr.data.element)).base;
		self.expr(e);

		switch t := e.eType; t.type {
		case ast.TypeType.POINTER:
			expr.eType = cast(*ast.Type)t.data.pointer.base;
			break;
		case ast.TypeType.ARRAY:
			expr.eType = cast(*ast.Type)t.data.array.base;
			break;
		case ast.TypeType.VECTOR:
			expr.eType = cast(*ast.Type)t.data.vector.base;
			break;
		default:
			break;
		}
	};
	func castExpr(self: *Analyzer, expr: *ast.Expr){
		e := *cast(*ast.CastExpr)&expr.data.castExpr;
		type := e.type;
		exp := e.expr;

		self.expr(exp);
		self.type(type);

		// handle casting rules here
		expr.eType = type;
	};
	func newExpr(self: *Analyzer, expr: *ast.Expr){
		e := *cast(*ast.NewExpr)&expr.data.newExpr;
		type, val := e.type, e.val;

		if val != null {
			self.expr(val);
		}
		if type != null {
			self.type(type);
		} else if val != null {
			type, expr.data.newExpr.type = val.eType, val.eType;
		} else {
			self.error("bruh you baf");
		}
		expr.eType = self.pointerToType(type);
	};
	func sizeExpr(self: *Analyzer, expr: *ast.Expr){
		self.expr(expr.data.sizeExpr.expr);
		expr.eType = SizeType;
	};
	func awaitExpr(self: *Analyzer, expr: *ast.Expr){
		e := cast(*ast.Expr)expr.data.awaitExpr.expr;
		self.expr(e);
		self.assert(e.eType.type == ast.TypeType.PROMISE, "bruh");

		expr.eType = e.eType.data.promse.base;
	};
	func callExpr(self: *Analyzer, expr: *ast.Expr){
		call := *cast(*ast.CallExpr)(&expr.data.callExpr);
		fnc := call.function;
		self.expr(fnc);

		type := *cast(*ast.FuncType)(&fnc.eType.data.fnc);

		e := fnc;

		if e.type == ast.ExprType.GENCALL {
			e = e.data.genCall.expr;
		}
		if e.type != ast.ExprType.MEMBER {
			goto next;
		}
		e = e.data.member.base;
		t := e.eType;

		if type.args.types.length == 0 {
			goto end;
		}

		t2 := type.args.types[0];
		x: vec *ast.Expr;

		if self.compareTypes(t, t2) {
			x = (vec *ast.Expr){};
			x.push(e);
		} else if t.type == ast.TypeType.POINTER && self.compareTypes(t.data.pointer.base, t2) {
			x = (vec *ast.Expr){};
			x.push(self.dereference(e));
		} else if t2.type == ast.TypeType.POINTER && self.compareTypes(t, t2.data.pointer.base) {
			x = (vec *ast.Expr){};
			x.push(self.pointerToExpr(e));
		} else {
			goto next;
		}
		if call.args != null {
			x.concat(call.args);
			call.args.free();
		}
		expr.data.callExpr.args = x;

	label next:
		if cast(*void)expr.data.callExpr.args != null {
			self.exprVec(expr.data.callExpr.args);
		}
	label end:
		// temporary
		if fnc.eType != null {
			expr.eType = type.returnType;
		} else {
			fnc.println();
		}
	};
	func memberExpr(self: *Analyzer, expr: *ast.Expr){
		member := *cast(*ast.MemberExpr)(&expr.data.member);

		e := member.base;

		if e.type == ast.ExprType.IDENT {
			an := self.getImportContext(e);

			if an != null {
				expr.buff = member.prop.tok.buff;
				expr.len = member.prop.tok.len;
				expr.type = ast.ExprType.IDENT;

				an.expr(expr);
				return;
			}
		}

		self.expr(e);

		type := e.eType;

		if type.type == ast.TypeType.POINTER {
			type = type.data.pointer.base;
		}
		type = self.getRootType(type);

		switch type.type {
		case ast.TypeType.STRUCT:
			goto strctProp;
		default:
			self.error("meh");
			break;
		}

	label strctProp:
		prop := member.prop;
		strct := *cast(*ast.StructType)(&type.data.strct);

		t := self.getPropType(strct, prop.tok.buff, prop.tok.len);

		switch t.type {
		case ast.TypeType.TEMPLATE:
			prop.name.type = names.NameType.METHOD;
			break;
		case ast.TypeType.FUNC:
			if cast(ast.FuncTypeEnum2)t.data.fnc.type2 == ast.FuncTypeEnum2.NATIVE {
				prop.name.type = names.NameType.METHOD;
				break;
			}
		default:
			prop.name.type = names.NameType.STRUCT_PROP;
			break;
		}
		prop.name.index = self.namespace;
		expr.eType = t;
		return;
	};
	func genCallExpr(self: *Analyzer, expr: *ast.Expr){
		e := cast(*ast.Expr)expr.data.genCall.expr;
		self.expr(e);

		tmplate := *cast(*ast.TemplateType)(&e.eType.data.tmplate);
		params := tmplate.params;
		args := tmplate.args;

		self.assert(tmplate.type == ast.TypeExprEnum.EXPR, "bruh genCallExpr()");
		types := cast(vec *ast.Type)expr.data.genCall.types;

		for i := 0; i < types.length; ++i {
			self.type(types[i]);
		}

		i := 0;
		for i < args.length && !self.compareTypeVec(args[i], types) { ++i; }

		expr.data.genCall.index = i;

		if i != args.length {
			return;
		}
		self.pushScope();

		for i := 0; i < types.length; ++i {
			t := types[i];
			t.labl = 1;
			self.addType(params[i].tok.buff, params[i].tok.len, t);
		}
		ee := deepcopy.copyExpr(tmplate.data.expr);

		self.expr(ee);
		expr.eType = (ee).eType;
		self.popScope();

		args.push(cast(vec *ast.Type)expr.data.genCall.types);
		tmplate.datas.push((ast.TypeExprUnion){expr: ee});
	};
	func funcExpr(self: *Analyzer, expr: *ast.Expr){
		fnc := cast(*ast.FuncExpr)(&expr.data.funcExpr);
		type := *cast(*ast.FuncType)(&fnc.type.data.fnc);

		names := type.args.names;
		types := type.args.types;

		self.pushScope();
		self.type(type.returnType);

		name: ast.IdentExpr;
		type2: *ast.Type;

		for i := 0; i < names.length; ++i {
			name = names[i];
			type2 = types[i];

			self.type(type2);
			self.var(&names[i].name);
			self.addVar(name.tok.buff, name.tok.len, type2);
		}
		self.block(fnc.body);
		self.popScope();

		expr.eType = fnc.type;
		self.heap.push(expr.eType);
	};
	func genricExpr(self: *Analyzer, expr: *ast.Expr){
		genric := *cast(*ast.GenericExpr)(&expr.data.genric);
		i := 0;
		for i < genric.conds.length && !self.compareTypes(genric.type, genric.conds[i]) { ++i; }
		expr.data.genric.index = i;
	};
	func genCallType(self: *Analyzer, type: *ast.Type){
		e := cast(*ast.Expr)type.data.genCall.expr;
		self.basicExprTypeExpr(e);

		tmplate := *cast(*ast.TemplateType)(&e.eType.data.tmplate);
		params := tmplate.params;
		args := tmplate.args;

		self.assert(tmplate.type == ast.TypeExprEnum.TYPE, "bruh genCallType()");

		types := cast(vec *ast.Type)type.data.genCall.types;

		i := 0;
		for i < args.length && !self.compareTypeVec(args[i], types) { ++i; }

		type.data.genCall.index = i;

		if i != args.length {
			return;
		}
		self.pushScope();

		for i := 0; i < types.length; ++i {
			t := types[i];
			t.labl = 1;
			self.addType(params[i].tok.buff, params[i].tok.len, t);
		}

		tt := deepcopy.copyType(tmplate.data.type);
		self.type(tt);

		self.popScope();

		args.push(cast(vec *ast.Type)type.data.genCall.types);
		tmplate.datas.push((ast.TypeExprUnion){type: tt});
	};
	func normalizeType(self: *Analyzer, type: *ast.Type) *ast.Type {
		switch type.type {
		case ast.TypeType.CONST:
			return self.normalizeType(type.data.cnst.base);
		default:
			return type;
		}
	};
	func typeVec(self: *Analyzer, types: *void){
		typeVec := cast(vec *ast.Type)types;
		for i := 0; i < typeVec.length; ++i {
			self.type(typeVec[i]);
		}
	};
	func type(self: *Analyzer, type: *ast.Type){
		switch type.type {
		case ast.TypeType.EXPR:
			self.basicExprType(type);
			break;
		case ast.TypeType.GENCALL:
			self.genCallType(type);
			break;
		case ast.TypeType.POINTER:
			self.type(cast(*ast.Type)type.data.pointer.base);
			break;
		case ast.TypeType.ARRAY:
			self.type(cast(*ast.Type)type.data.array.base);
			break;
		case ast.TypeType.IMPARRAY:
			self.type(cast(*ast.Type)type.data.impArray.base);
			break;
		case ast.TypeType.STRUCT:
			self.structType(type.data.strct);
			break;
		case ast.TypeType.TEMPLATE:
			self.templateType(type.data.tmplate);
			break;
		case ast.TypeType.FUNC:
			self.funcType(type.data.fnc);
			break;
		default:
			break;
		}
	};
	func basicExprType(self: *Analyzer, type: *ast.Type){
		expr := cast(*ast.Expr)type.data.expr.expr;

		if expr.type == ast.ExprType.IDENT {
			self.var(&expr.data.name);
			t := self.getType(expr.buff, expr.len);

			if t.labl == 0 {
				expr.eType = t;
			} else {
				type.type = t.type;
				type.data = t.data;
				type.buff = t.buff;
				type.len = t.len;
			}
		}
	};
	func basicExprTypeExpr(self: *Analyzer, expr: *ast.Expr){
		if expr.type == ast.ExprType.IDENT {
			self.var(&expr.data.name);
			expr.eType = self.getType(expr.buff, expr.len);
		}
	};
	func structType(self: *Analyzer, strct: ast.StructType){
		self.pushScope();
		for i := 0; i < strct.props.length; ++i {
			self.structProp(strct.props[i]);
		}
		self.popScope();
	};
	func structProp(self: *Analyzer, stmt: *ast.Stmt){
		switch stmt.type {
		case ast.StmtType.FUNC:
			self.pushScope();
			self.funcDecNoAdd(stmt.data.funcDec);
			self.popScope();

			ident := cast(*ast.IdentExpr)stmt.data.funcDec.name;
			ident.name.index = self.namespace;
			ident.name.type = names.NameType.METHOD;
			break;
		case ast.StmtType.TEMPLATE:
			self.tmplateNoAdd(stmt.data.tmplate);
			ident = stmt.data.tmplate.name;
			ident.name.index = self.namespace;
			ident.name.type = names.NameType.METHOD;
			break;
		default:
			self.decNoAdd(stmt.data.dec);

			dec := *cast(*ast.Declaration)(&stmt.data.dec);
			for i, ident := 0, dec.idents[0]; i < dec.idents.length; ident = dec.idents[++i] {
				ident.data.name.index = self.namespace;
				ident.data.name.type = names.NameType.STRUCT_PROP;
			}
			break;
		}
	};
	func templateType(self: *Analyzer, tmplate: ast.TemplateType){
		for i := 0; i < tmplate.params.length; ++i {
			self.var(&tmplate.params[i].name);
		}
	};
	func funcType(self: *Analyzer, fnc: ast.FuncType){
		if fnc.returnType != null {
			self.type(fnc.returnType);
		}
		if fnc.args.names == null {
			self.typeVec(fnc.args.types);
		} else {
			ident: *ast.IdentExpr;
			type: *ast.Type;

			for i := 0; i < fnc.args.names.length; ++i {
				ident = &fnc.args.names[i];
				type = fnc.args.types[i];

				self.type(type);
				self.ident(ident);
				self.addVar(ident.tok.buff, ident.tok.len, type);
			}
		}
		if fnc.varargs != null && fnc.varargs != cast(*void)1 {
			self.ident(fnc.varargs);

			t := new ast.Type;
			t.type = ast.TypeType.EXPR;
			t.data.expr = (ast.BasicExprType){
				expr: new ast.Expr{
					type:   ast.ExprType.IDENT,
					buff:   "_Arguments",
					len:    10,
					line:   fnc.varargs.tok.line,
					column: fnc.varargs.tok.column
				}
			};

			self.heap.push(t);
			self.type(t);
			self.addVar(fnc.varargs.tok.buff, fnc.varargs.tok.len, t);
		}
	};
	func pointerToType(self: *Analyzer, type: *ast.Type) *ast.Type {
		t := new ast.Type{
			type: ast.TypeType.POINTER,
			data: (ast.TypeUnion){pointer: (ast.PointerType){base: type}}
		};
		self.heap.push(t);
		return t;
	};
	func pointerToExpr(self: *Analyzer, expr: *ast.Expr) *ast.Expr {
		op := new ast.Operator{
			tok: (tokens.Token){ pType: tokens.PTokenType.BITW_OP, sType: tokens.STokenType.AND, buff: "&", len: 1}
		};
		e := new ast.Expr{
			type: ast.ExprType.UNARY,
			data: (ast.ExprUnion){unary: (ast.UnaryExpr){op: op, expr: expr}}
		};
		self.heap.push(op);
		self.heap.push(e);
		return e;
	};
	func dereference(self: *Analyzer, expr: *ast.Expr) *ast.Expr {
		op := new ast.Operator{
			tok: (tokens.Token){ pType: tokens.PTokenType.ARITH_OP, sType: tokens.STokenType.MUL, buff: "*", len: 1}
		};
		e := new ast.Expr{
			type: ast.ExprType.UNARY,
			data: (ast.ExprUnion){unary: (ast.UnaryExpr){op: op, expr: expr}}
		};
		self.heap.push(op);
		self.heap.push(e);
		return e;
	};
	func getPropType(self: *Analyzer, type: ast.StructType, buff: *i8, len: size_t) *ast.Type {
		for i, l := 0, type.props.length; i < l; ++i {
			s := type.props[i];
			switch s.type {
			case ast.StmtType.FUNC:
				goto fnc;
			case ast.StmtType.TEMPLATE:
				goto tmplate;
			default:
				goto dec;
			}

		label fnc:
			tok := (cast(*ast.IdentExpr)s.data.funcDec.name).tok;
			if tok.len != len || mem.compare(buff, tok.buff, len) != 0 {
				continue;
			}
			return s.data.funcDec.type;
		label tmplate:
			tok = (cast(*ast.IdentExpr)s.data.tmplate.name).tok;
			if tok.len != len || mem.compare(buff, tok.buff, len) != 0 {
				continue;
			}
			return s.data.tmplate.type;
		label dec:
			dec := *cast(*ast.Declaration)(&s.data.dec);
			for x, ident := 0, dec.idents[0]; x < dec.idents.length; ident = dec.idents[++x] {
				if ident.len != len || mem.compare(buff, ident.buff, len) != 0 {
					continue;
				}
				return dec.types[x];
			}
			continue;
		}
		return null;
	};
	func compareTypes(self: *Analyzer, type1: *ast.Type, type2: *ast.Type) bool {
		if type1.type != type2.type {
			return false;
		}
		switch type1.type {
		case ast.TypeType.BASIC:
		case ast.TypeType.EXPR:
			return (cast(*ast.Expr)type1.data.expr.expr).len == (cast(*ast.Expr)type2.data.expr.expr).len && mem.compare((cast(*ast.Expr)type1.data.expr.expr).buff, (cast(*ast.Expr)type2.data.expr.expr).buff, (cast(*ast.Expr)type1.data.expr.expr).len) == 0;
		case ast.TypeType.POINTER:
			return self.compareTypes(type1.data.pointer.base, type2.data.pointer.base);
		case ast.TypeType.CONST:
			return self.compareTypes(type1.data.cnst.base, type2.data.cnst.base);
		default:
			return true;
		}
	};
	func compareTypeVec(self: *Analyzer, types1: *void, types2: *void) bool {
		typeVec1 := cast(vec *ast.Type)types1;
		typeVec2 := cast(vec *ast.Type)types2;

		if typeVec1.length != typeVec2.length {
			return false;
		}

		i := 0;
		for i < typeVec1.length && self.compareTypes(typeVec1[i], typeVec2[i]) { ++i; }
		return i == typeVec1.length;
	};
	func getRootType(self: *Analyzer, type: *ast.Type) *ast.Type {
		if type.type == ast.TypeType.EXPR {
			t := (cast(*ast.Expr)type.data.expr.expr).eType;
			return t != null ? t : type;
		}
		return type;
	};
};

export func NewAnalyzer(b: [6]i8, l: u16) Analyzer {
	a := (Analyzer){
		symbols:     symbols.NewSymbolTable(null),
		heap:        (vec *void){},
		namespace:   (names.NameSpace){len: l},
		context:     NewAnalyzerContext(),
		exports:     symbols.NewSymbolTable(null),
		imports:     (vec *Analyzer){},
		importNames: (vec *ast.IdentExpr){}
	};
	mem.copy(a.namespace.buff, b, l);
	return a;
};
