import "io.vo";
import "mem.vo";
import "num.vo";
import "tokens.vo";
import "ast.vo";
import "names.vo";

func appendToVec(v: vec i8, str: *i8, len: i32){
	v.append(str, len);
};

struct TypeContext {
	bottom: size_t;
	buf: vec i8;

	func insert(self: *TypeContext, buf: *i8, len: size_t){
		newBuf := (vec i8){};
		for i := 0; i < self.bottom; ++i {
			newBuf.push(self.buf[i]);
		}
		for i := 0; i < len; ++i {
			newBuf.push(buf[i]);
		}
		for i := self.bottom; i < self.buf.length; ++i {
			newBuf.push(self.buf[i]);
		}
		self.buf.free();
		self.buf = newBuf;
		self.bottom += len;
	};
	func append(self: *TypeContext, buf: *i8, len: size_t){
		self.buf.append(buf, len);
	};
	func push(self: *TypeContext, char: i8){
		self.buf.push(char);
	};
	func num(self: *TypeContext, lit: *ast.BasicLit){
		if lit.tok.buff[1] == 'o' {
			self.push('0');
			self.append(lit.tok.buff + 2, lit.tok.len-2);
		} else {
			self.append(lit.tok.buff, lit.tok.len);
		}
	};
	func free(self: *TypeContext){
		self.buf.free();
	};
};
func NewTypeContext() TypeContext {
	return (TypeContext){
		bottom: 0,
		buf: (vec i8){}
	};
};

struct CompilerContext {
	num:     u32;
	mcases:  vec *ast.Pattern;
	stack:   vec *ast.Stmt;
	varargs: *ast.IdentExpr;

	func free(self: *CompilerContext){
		self.mcases.free();
		self.stack.free();
	};
	func reset(self: *CompilerContext){
		self.num = 0;
		self.mcases.length = 0;
		self.stack.length  = 0;
	};
};
func NewCompilerContext() CompilerContext {
	return (CompilerContext){
		num:     0,
		mcases:  (vec *ast.Pattern){},
		stack:   (vec ast.StmtType){},
		varargs: null,
	};
};

typedef BuffCb *func(*void, *i8, u32);

export struct Buff {
	raw: [0x100]i8;
	length: u32;

	cb:   *func(*void, *i8, u32);
	data: *void;

	func push(self: *Buff, chr: i8){
		if self.length != 0x100 {
			self.raw[self.length++] = chr;
		} else {
			self.flush();
			self.raw[0] = chr;
			self.length = 1;
		}
	};
	func append(self: *Buff, str: *i8, len: u32){
		m: *i64;
		s: *i64 = cast(*i64)str;

		if self.length + len < 0x100 {
			m = cast(*i64)(self.raw + self.length);
			goto next;
		}
		self.checkNFlush();

		m = cast(*i64)self.raw;
		turns := len / 0x100;

		for i := 0; i < turns; ++i {
			m[0x00] = s[0x00];
			m[0x01] = s[0x01];
			m[0x02] = s[0x02];
			m[0x03] = s[0x03];
			m[0x04] = s[0x04];
			m[0x05] = s[0x05];
			m[0x06] = s[0x06];
			m[0x07] = s[0x07];
			m[0x08] = s[0x08];
			m[0x09] = s[0x09];
			m[0x0A] = s[0x0A];
			m[0x0B] = s[0x0B];
			m[0x0C] = s[0x0C];
			m[0x0D] = s[0x0D];
			m[0x0E] = s[0x0E];
			m[0x0F] = s[0x0F];

			m[0x10] = s[0x10];
			m[0x11] = s[0x11];
			m[0x12] = s[0x12];
			m[0x13] = s[0x13];
			m[0x14] = s[0x14];
			m[0x15] = s[0x15];
			m[0x16] = s[0x16];
			m[0x17] = s[0x17];
			m[0x18] = s[0x18];
			m[0x19] = s[0x19];
			m[0x1A] = s[0x1A];
			m[0x1B] = s[0x1B];
			m[0x1C] = s[0x1C];
			m[0x1D] = s[0x1D];
			m[0x1E] = s[0x1E];
			m[0x1F] = s[0x1F];

			s += 0x20;
			self.flush();
		}

	label next:
		extras := len % 0x100;

		switch extras / 8 {
		case 0x1F: *m++ = *s++;
		case 0x1E: *m++ = *s++;
		case 0x1D: *m++ = *s++;
		case 0x1C: *m++ = *s++;
		case 0x1B: *m++ = *s++;
		case 0x1A: *m++ = *s++;
		case 0x19: *m++ = *s++;
		case 0x18: *m++ = *s++;
		case 0x17: *m++ = *s++;
		case 0x16: *m++ = *s++;
		case 0x15: *m++ = *s++;
		case 0x14: *m++ = *s++;
		case 0x13: *m++ = *s++;
		case 0x12: *m++ = *s++;
		case 0x11: *m++ = *s++;
		case 0x10: *m++ = *s++;

		case 0x0F: *m++ = *s++;
		case 0x0E: *m++ = *s++;
		case 0x0D: *m++ = *s++;
		case 0x0C: *m++ = *s++;
		case 0x0B: *m++ = *s++;
		case 0x0A: *m++ = *s++;
		case 0x09: *m++ = *s++;
		case 0x08: *m++ = *s++;
		case 0x07: *m++ = *s++;
		case 0x06: *m++ = *s++;
		case 0x05: *m++ = *s++;
		case 0x04: *m++ = *s++;
		case 0x03: *m++ = *s++;
		case 0x02: *m++ = *s++;
		case 0x01: *m++ = *s++;
		}

		m2 := cast(*i8)(m);
		s2 := cast(*i8)(s);

		switch extras % 8 {
		case 7: *m2++ = *s2++;
		case 6: *m2++ = *s2++;
		case 5: *m2++ = *s2++;
		case 4: *m2++ = *s2++;
		case 3: *m2++ = *s2++;
		case 2: *m2++ = *s2++;
		case 1: *m2++ = *s2++;
		}
		self.length += extras;
	};
	func flush(self: *Buff){
		c := self.cb;
		(*c)(self.data, cast(*i8)self.raw, self.length);
		self.length = 0;
	};
	func checkNFlush(self: *Buff){
		if self.length != 0 {
			self.flush();
		}
	};
};
func NewBuff(cb: *func(*void, *i8, u32), data: *void) Buff {
	return (Buff){cb: cb, data: data, length: 0};
};

export struct Compiler {
	scopeCount: u32;
	context:    CompilerContext;
	buff:       Buff;

	func push(self: *Compiler, char: i8){
		self.buff.push(char);
	};
	func append(self: *Compiler, str: *i8, len: size_t){
		self.buff.append(str, len);
	};
	func macroAppend(self: *Compiler, str: *i8, len: size_t){
		for i := 0; i < len; ++i {
			if str[i] == '\n' {
				self.push('\\');
			}
			self.push(str[i]);
		}
	};
	func openParen(self: *Compiler){
		self.push('(');
	};
	func closeParen(self: *Compiler){
		self.push(')');
	};
	func openBrace(self: *Compiler){
		self.push('[');
	};
	func closeBrace(self: *Compiler){
		self.push(']');
	};
	func openCBrace(self: *Compiler){
		self.push('{');
	};
	func closeCBrace(self: *Compiler){
		self.push('}');
	};
	func dot(self: *Compiler){
		self.push('.');
	};
	func colon(self: *Compiler){
		self.push(':');
	};
	func comma(self: *Compiler){
		self.push(',');
	};
	func semicolon(self: *Compiler){
		self.push(';');
	};
	func equal(self: *Compiler){
		self.push('=');
	};
	func newline(self: *Compiler){
		self.push('\n');
	};
	func space(self: *Compiler){
		self.push(' ');
	};
	func tab(self: *Compiler){
		self.push('\t');
	};

	func pushScope(self: *Compiler){
		++self.scopeCount;
	};
	func popScope(self: *Compiler){
		--self.scopeCount;
	};

	func indent(self: *Compiler){
		for i := 0; i < self.scopeCount; ++i {
			self.tab();
		}
	};
	func ident(self: *Compiler, ident: *ast.IdentExpr){
		p := names.getPrefix(ident.name.type);
		self.push(p);

		if names.isIndexed(ident.name.type) {
			self.append(ident.name.index.buff, ident.name.index.len);
		}
		self.push('_');
		self.append(cast(*i8)ident.tok.buff, ident.tok.len);
	};
	func operator(self: *Compiler, op: *ast.Operator){
		self.append(cast(*i8)op.tok.buff, op.tok.len);
	};
	func basicLit(self: *Compiler, lit: *ast.Expr){
		self.append(cast(*i8)lit.buff, lit.len);
	};
	func file(self: *Compiler, file: ast.File) {
		self.append("#ifndef H_VO_", 13);
		self.append(file.namespace.buff, file.namespace.len);
		self.newline();

		self.append("#define H_VO_", 13);
		self.append(file.namespace.buff, file.namespace.len);
		self.newline();

		self.append("#include \"internal/default.h\"\n", 30);
		i: i32;

		for i = 0; i < file.___cs.length; ++i {
			self.___c(file.___cs[i].data.___c);
			self.semicolon();
			self.newline();
		}
		self.newline();
		for i = 0; i < file.imprts.length; ++i {
			self.imprt(file.imprts[i].data.imprt);
			self.newline();
		}
		self.newline();
		for i = 0; i < file.tdefs.length; ++i {
			self.globalTypedef1(file.tdefs[i].stmt.data.tdef);
		}
		self.newline();
		for i = 0; i < file.tdefs.length; ++i {
			self.globalTypedef2(file.tdefs[i].stmt.data.tdef);
		}
		self.newline();
		for i = 0; i < file.tmplates.length; ++i {
			self.tmplate(file.tmplates[i].stmt.data.tmplate);
		}
		self.newline();
		for i = 0; i < file.funcs.length; ++i {
			self.globalFuncDec1(file.funcs[i].stmt.data.funcDec);
		}
		self.newline();
		for i = 0; i < file.decs.length; ++i {
			self.globalDec(file.decs[i].stmt.data.dec);
		}
		self.newline();
		for i = 0; i < file.tdefs.length; ++i {
			self.globalTypedef3(file.tdefs[i].stmt.data.tdef);
		}
		self.newline();
		for i = 0; i < file.funcs.length; ++i {
			self.globalFuncDec2(file.funcs[i].stmt.data.funcDec);
		}

		self.append("#endif", 6);
		self.buff.checkNFlush();
	};
	func imprt(self: *Compiler, imprt: ast.Import){
		self.append("#include \"", 10);
		self.append(imprt.path.tok.buff+1, imprt.path.tok.len-2);
		self.push('.');
		self.push('c');
		self.push('"');
	};
	func globalDec(self: *Compiler, dec: ast.Declaration){
		self.dec(dec);
		self.semicolon();
		self.newline();
	};
	func globalTypedef1(self: *Compiler, tdef: ast.Typedef){
		switch tdef.type.type {
		case ast.TypeType.STRUCT:
			self.append("typedef struct ", 15);
			self.ident(tdef.name);
			self.space();
			self.ident(tdef.name);
			break;
		default:
			self.append("typedef ", 8);
			self.decTypeIdent(tdef.type, tdef.name);
			break;
		}
		self.semicolon();
		self.newline();
	};
	func globalTypedef2(self: *Compiler, tdef: ast.Typedef){
		if tdef.type.type != ast.TypeType.STRUCT {
			return;
		}

		self.append("typedef struct ", 15);
		self.ident(tdef.name);
		self.space();
		self.openCBrace();
		self.pushScope();

		strct := *cast(*ast.StructType)(&tdef.type.data.strct);
		l := strct.props.length;

		for i := 0; i < l; ++i {
			s := strct.props[i];

			if s.type != ast.StmtType.DEC {
				continue;
			}
			self.newline();
			self.indent();
			self.dec(s.data.dec);
			self.semicolon();
		}

		self.popScope();
		self.newline();
		self.closeCBrace();
		self.ident(tdef.name);
		self.semicolon();
		self.newline();
		self.newline();

		for i := 0; i < l; ++i {
			s := strct.props[i];

			if s.type != ast.StmtType.FUNC {
				continue;
			}
			self.funcDecNoBlockNIdent(s.data.funcDec, strct.name);
			self.semicolon();
			self.newline();
		}
		for i := 0; i < l; ++i {
			s := strct.props[i];

			if s.type != ast.StmtType.TEMPLATE {
				continue;
			}
			self.tmplateOnlyDec(s.data.tmplate);
			self.semicolon();
			self.newline();
		}
	};
	func globalTypedef3(self: *Compiler, tdef: ast.Typedef){
		if tdef.type.type != ast.TypeType.STRUCT {
			return;
		}
		strct := *cast(*ast.StructType)(&tdef.type.data.strct);
		l := strct.props.length;

		for i := 0; i < l; ++i {
			s := strct.props[i];
			switch s.type {
			case ast.StmtType.FUNC:
				self.funcDecNIdent(s.data.funcDec, strct.name);
				break;
			case ast.StmtType.TEMPLATE:
				self.tmplate(s.data.tmplate);
				break;
			default:
				continue;
			}
			self.semicolon();
			self.newline();
		}
	};
	func globalTemplate1(self: *Compiler, tmplate: ast.Template){
		if cast(ast.TypeExprEnum)tmplate.type.data.tmplate.type != ast.TypeExprEnum.TYPE {
			return;
		}
		buff: [15]i8 = {'g'};

		type := *cast(*ast.TemplateType)(&tmplate.type.data.tmplate);

		if (cast(*ast.Type)type.data.type).type == ast.TypeType.STRUCT {
			for i: u32 = 0; i < type.datas.length; ++i {
				self.append("typedef struct ", 15);

				l := num.utos(i, cast(*i8)buff+1);
				self.append(buff, l);
				self.ident(tmplate.name);
				self.space();
				self.append(buff, l);
				self.ident(tmplate.name);
			}
			return;
		}
		for i: u32 = 0; i < type.datas.length; ++i {
			x := type.datas[i];
			arg := type.args[i];

			l := num.utos(i, cast(*i8)buff+1);

			for j := 0; j < type.params.length; ++j {
				self.append("#define ", 8);
				self.ident(&type.params[j]);
				self.space();
				self.type(arg[j]);

				self.reset();
				self.newline();
			}

			self.append("typedef ", 8);
			self.decTypeIdentNBuff(x.type, tmplate.name, buff, l);
			self.semicolon();

			for j := 0; j < type.params.length; ++j {
				self.newline();
				self.append("#undef ", 7);
				self.ident(&type.params[j]);
			}
			self.newline();
		}
	};
	func globalFuncDec1(self: *Compiler, fnc: ast.FuncDec){
		self.funcDecNoBlock(fnc);
		self.semicolon();
		self.newline();
	};
	func globalFuncDec2(self: *Compiler, fnc: ast.FuncDec){
		self.funcDec(fnc);
		self.semicolon();
		self.newline();
	};
	func stmt(self: *Compiler, stmt: *ast.Stmt){
		self.newline();
		self.indent();
		self.stmtRaw(stmt);
		self.semicolon();
	};
	func stmtRaw(self: *Compiler, stmt: *ast.Stmt){
		switch stmt.type {
		case ast.StmtType.DEC:
			self.dec(stmt.data.dec);
			break;
		case ast.StmtType.ASSIGN:
			self.assign(stmt.data.assign);
			break;
		case ast.StmtType.EXPR:
			self.exprStmt(stmt.data.expr);
			break;
		case ast.StmtType.RETURN:
			self.rturn(stmt.data.rturn);
			break;
		case ast.StmtType.IF_ELSE:
			self.ifElse(stmt.data.ifElse);
			break;
		case ast.StmtType.SWITCH:
			self.swtch(stmt.data.swtch);
			break;
		case ast.StmtType.MATCH:
			self.mtch(stmt.data.mtch);
			break;
		case ast.StmtType.GENERIC:
			self.context.stack.push(stmt);
			self.genric(stmt.data.genric);
			self.context.stack.pop();
			break;
		case ast.StmtType.LOOP:
			self.loop(stmt.data.loop);
			break;
		case ast.StmtType.FUNC:
			self.funcDec(stmt.data.funcDec);
			break;
		case ast.StmtType.BLOCK:
			self.block(stmt.data.block);
			break;
		case ast.StmtType.LABEL:
			self.labl(stmt.data.labl);
			break;
		case ast.StmtType.GOTO:
			self.gotoh(stmt.data.gotoh);
			break;
		case ast.StmtType.BREAK:
			self.brak();
			break;
		case ast.StmtType.CONTINUE:
			self.continuee();
			break;
		case ast.StmtType.SCASE:
			self.switchCase(stmt.data.scase);
			break;
		case ast.StmtType.GCASE:
			self.genericCase(stmt.data.gcase);
			break;
		case ast.StmtType.MCASE:
			self.matchCase(stmt.data.mcase);
			break;
		case ast.StmtType.DELETE:
			self.del(stmt.data.del);
			break;
		case ast.StmtType.DEFAULT:
			self.defalt();
			break;
		case ast.StmtType.TYPEDEF:
			self.tdef(stmt.data.tdef);
			break;
		case ast.StmtType.TEMPLATE:
			self.tmplate(stmt.data.tmplate);
			break;
		case ast.StmtType.__C:
			self.___c(stmt.data.___c);
			break;
		default:
			break;
		}
	};
	func ___c(self: *Compiler, ___c: ast.__C){
		for i := 0; i < ___c.stuff.length; ++i {
			self.expr(___c.stuff[i]);
		}
	};
	func defalt(self: *Compiler){
		s := self.context.stack[self.context.stack.length-1];
		if s.type == ast.StmtType.GENERIC {
			self.append("il_in:", 6);
		} else {
			self.append("default:", 8);
		}
	};
	func brak(self: *Compiler){
		s := self.context.stack[self.context.stack.length-1];
		if s.type == ast.StmtType.GENERIC {
			self.append("goto il_out", 11);
		} else {
			self.append("break", 5);
		}
	};
	func continuee(self: *Compiler){
		self.append("continue", 8);
	};
	func switchCase(self: *Compiler, scase: ast.SwitchCase){
		self.append("case ", 5);
		self.expr(scase.val);
		self.colon();
	};
	func matchCase(self: *Compiler, mcase: ast.MatchCase){
		self.append("case ", 5);
		s: [10]i8;
		self.append(s, num.utos(self.context.num++, s));
		self.colon();
		self.context.mcases.push(mcase.val);
	};
	func genericCase(self: *Compiler, gcase: ast.GenericCase){
		self.append("il_in:", 6);
	};
	func del(self: *Compiler, del: ast.Delete){
		self.append("free(", 5);
		self.expr(del.exprs[0]);
		self.closeParen();

		for i := 1; i < del.exprs.length; ++i {
			self.semicolon();
			self.newline();
			self.indent();

			self.append("free(", 5);
			self.expr(del.exprs[i]);
			self.closeParen();
		}
	};
	func exprStmt(self: *Compiler, stmt: ast.ExprStmt){
		self.expr(stmt.expr);
	};
	func dec(self: *Compiler, dec: ast.Declaration){
		if dec.values == null {
			self.decNoVal(dec);
		} else {
			self.decVal(dec);
		}
	};
	func decVal(self: *Compiler, dec: ast.Declaration){
		i := 0;

		b := ([5]*i8){"", "static ", "extern ", "extern ", "register "}[dec.sClass];
		l := ([5]size_t){0, 7, 7, 7, 9}[dec.sClass];

		if dec.sClass != ast.StorageClass.C_EXTERN {
			goto body2;
			for ; i < dec.idents.length; ++i {
				self.semicolon();
				self.newline();
				self.indent();

			label body2:
				self.append(b, l);
				self.decType(dec.types[i], dec.idents[i]);
				self.space();
				self.equal();
				self.space();
				self.expr(dec.values[i]);
			}
		} else {
			goto body1;
			for ; i < dec.idents.length; ++i {
				self.semicolon();
				self.newline();
				self.indent();

			label body1:
				self.append("#define ", 8);
				self.expr(dec.idents[i]);
				self.space();
				self.append(dec.idents[i].buff, dec.idents[i].len);
				self.newline();
				self.indent();
				self.append(b, l);
				self.decType(dec.types[i], dec.idents[i]);
				self.space();
				self.equal();
				self.space();
				self.expr(dec.values[i]);
			}
		}
	};
	func decNoVal(self: *Compiler, dec: ast.Declaration){
		i := 0;

		b := ([5]*i8){"", "static ", "extern ", "extern ", "register "}[dec.sClass];
		l := ([5]size_t){0, 7, 7, 7, 9}[dec.sClass];

		if dec.sClass != ast.StorageClass.C_EXTERN {
			goto body2;
			for ; i < dec.idents.length; ++i {
				self.semicolon();
				self.newline();
				self.indent();

			label body2:
				self.append(b, l);
				self.decType(dec.types[i], dec.idents[i]);
			}
		} else {
			goto body1;
			for ; i < dec.idents.length; ++i {
				self.semicolon();
				self.newline();
				self.indent();

			label body1:
				self.append("#define ", 8);
				self.expr(dec.idents[i]);
				self.space();
				self.append(dec.idents[i].buff, dec.idents[i].len);
				self.space();
				self.newline();
				self.indent();
				self.append(b, l);
				self.decType(dec.types[i], dec.idents[i]);
			}
		}
	};
	func funcDecNoBlock(self: *Compiler, dec: ast.FuncDec){
		self.funcDecType(dec.type.data.fnc, dec.name);
	};
	func funcDecNoBlockNIdent(self: *Compiler, dec: ast.FuncDec, ident: *ast.IdentExpr){
		self.funcDecTypeNIdent(dec.type.data.fnc, dec.name, ident);
	};
	func funcDec(self: *Compiler, dec: ast.FuncDec){
		self.funcDecNoBlock(dec);
		self.funcBody(dec.body, dec.type.data.fnc);
	};
	func funcDecNIdent(self: *Compiler, dec: ast.FuncDec, ident: *ast.IdentExpr){
		self.funcDecNoBlockNIdent(dec, ident);
		self.funcBody(dec.body, dec.type.data.fnc);
	};
	func blockNoBrace(self: *Compiler, block: ast.Block){
		for i := 0; i < block.stmts.length; ++i {
			self.stmt(block.stmts[i]);
		}
	};
	func block(self: *Compiler, block: ast.Block){
		self.openCBrace();
		self.pushScope();
		self.blockNoBrace(block);
		self.popScope();
		self.newline();
		self.indent();
		self.closeCBrace();
	};
	func assign(self: *Compiler, assign: ast.Assignment){
		self.expr(assign.vars[0]);
		self.operator(assign.op);
		self.expr(assign.vals[0]);

		for i := 1; i < assign.vars.length; ++i {
			self.semicolon();
			self.newline();
			self.expr(assign.vars[i]);
			self.operator(assign.op);
			self.expr(assign.vals[i]);
		}
	};
	func rturn(self: *Compiler, rturn: ast.Return){
		if self.context.varargs != null {
			self.append("va_end(", 7);
			self.ident(self.context.varargs);
			self.append(".p_list)", 8);
			self.semicolon();
			self.newline();
			self.indent();
		}
		self.append("return", 6);

		if rturn.val != null {
			self.space();
			self.expr(rturn.val);
		}
	};
	func ifElse(self: *Compiler, ifElse: ast.IfElse){
		c := 0;
		for i := 0; i < ifElse.blocks.length; ++i {
			init := ifElse.initStmts[i];
			cond := ifElse.conds[i];
			block := ifElse.blocks[i];

			if init != null {
				self.openCBrace();
				self.pushScope();
				self.stmt(init);
				self.newline();
				self.indent();
				++c;
			}
			self.append("if(", 3);
			self.expr(cond);
			self.closeParen();
			self.block(block);
			self.space();
			self.append("else", 4);
		}
		if ifElse.elseBlock.stmts != null {
			self.block(ifElse.elseBlock);
		}
		for c-- != 0 {
			self.popScope();
			self.newline();
			self.indent();
			self.closeCBrace();
		}
	};
	func swtch(self: *Compiler, swtch: ast.Switch){
		if swtch.initStmt != null {
			self.openCBrace();
			self.pushScope();
			self.stmt(swtch.initStmt);
			self.newline();
			self.indent();

			self.append("switch(", 7);
			self.expr(swtch.expr);
			self.closeParen();
			self.block(swtch.block);

			self.popScope();
			self.newline();
			self.indent();
			self.closeCBrace();
		} else {
			self.append("switch(", 7);
			self.expr(swtch.expr);
			self.closeParen();
			self.block(swtch.block);
		}
	};
	func genric(self: *Compiler, genric: ast.Generic){
		self.openCBrace();
		self.pushScope();

		self.newline();
		self.indent();

		first := genric.block.stmts[genric.start];
		self.append("__label__ il_in, il_out;", 24);

		if first.type != ast.StmtType.GCASE && first.type != ast.StmtType.DEFAULT {
			self.newline();
			self.indent();
			self.append("goto il_in;", 11);
		}
		// $printf("c: %i, %i\n", genric.start, genric.end);	

		for i := genric.start; i < genric.end; ++i {
			self.stmt(genric.block.stmts[i]);
		}

		self.popScope();
		self.newline();
		self.indent();
		self.append("il_out:;", 8);
		self.newline();
		self.indent();
		self.closeCBrace();
	};
	func loop(self: *Compiler, loop: ast.Loop){
		c: bool = loop.initStmt != null;
		if c {
			self.openCBrace();
			self.pushScope();
			self.stmt(loop.initStmt);
			self.newline();
			self.indent();
		}
		self.append("for(;", 5);

		if loop.cond != null {
			self.expr(loop.cond);
		}
		self.semicolon();

		if loop.loopStmt != null {
			self.stmtRaw(loop.loopStmt);
		}
		self.closeParen();
		self.block(loop.block);

		if c {
			self.newline();
			self.popScope();
			self.indent();
			self.closeCBrace();
		}
	};
	func mtch(self: *Compiler, mtch: ast.Match){
		self.openCBrace();
		self.pushScope();
		self.newline();
		self.indent();

		if mtch.initStmt != null {
			self.stmt(mtch.initStmt);
			self.newline();
			self.indent();
		}

		b := (vec i8){};
		c := (Compiler){
			scopeCount: self.scopeCount,
			buff: NewBuff(cast(BuffCb)(&appendToVec), b),
			context: NewCompilerContext()
		};
		c.block(mtch.block);
		c.buff.checkNFlush();

		self.append("register int i_s = -1;", 22);
		self.newline();
		self.indent();
		self.append("register typeof(", 16);
		self.expr(mtch.expr);
		self.append(") i_e = ", 8);
		self.expr(mtch.expr);
		self.semicolon();

		self.newline();
		self.newline();
		self.indent();

		patterns := c.context.mcases;
		temp: [10]i8;

		for pattern, i := patterns[0], cast(u32)0; i < patterns.length; pattern = patterns[++i] {
			self.append("if(", 3);
			self.pattern(pattern, "i_e", 3);
			self.closeParen();
			self.space();
			self.append("i_s = ", 6);
			self.append(cast(*i8)temp, num.utos(i, temp));
			self.semicolon();
			self.newline();
			self.indent();
			self.append("else ", 5);
		}
		self.semicolon();
		self.newline();
		self.newline();
		self.indent();

		self.append("switch(i_s)", 11);
		self.append(b.raw, b.length);
		b.free();

		self.popScope();
		self.newline();
		self.indent();
		self.closeCBrace();
	};
	func labl(self: *Compiler, labl: ast.Label){
		self.ident(labl.name);
		self.colon();
	};
	func gotoh(self: *Compiler, gotoh: ast.Goto){
		self.append("goto ", 5);
		self.ident(gotoh.name);
	};
	func tdef(self: *Compiler, tdef: ast.Typedef){
		self.append("typedef ", 8);
		self.decTypeIdent(tdef.type, tdef.name);
	};
	func tmplate(self: *Compiler, tmplate: ast.Template){
		buff: [10]i8 = {'g'};

		c := (Compiler){
			scopeCount: self.scopeCount,
			buff: NewBuff(cast(BuffCb)self.macroAppend, self),
			context: NewCompilerContext()
		};
		type := *cast(*ast.TemplateType)(&tmplate.type.data.tmplate);

		for i: u32 = 0; i < type.datas.length; ++i {
			x := type.datas[i];
			arg := type.args[i];

			for j := 0; j < type.params.length; ++j {
				c.append("#define ", 8);
				c.ident(&type.params[j]);
				c.space();
				c.type(arg[j]);

				c.reset();
				self.newline();
			}

			if type.type == ast.TypeExprEnum.TYPE {
				self.append("typedef ", 8);
				self.decTypeIdentNBuff(cast(*ast.Type)x.type, tmplate.name, buff, num.utos(i, cast(*i8)buff+1)+1);
			} else {
				self.decTypeIdentNBuff((cast(*ast.Expr)x.expr).data.funcExpr.type, tmplate.name, buff, num.utos(i, cast(*i8)buff+1)+1);
				self.block((cast(*ast.Expr)x.expr).data.funcExpr.body);
			}

			self.semicolon();
			for j := 0; j < type.params.length; ++j {
				self.newline();
				self.append("#undef ", 7);
				self.ident(&type.params[j]);
			}
			self.newline();
		}
	};
	func tmplateOnlyDec(self: *Compiler, tmplate: ast.Template){
		buff: [10]i8 = {'g'};

		c := (Compiler){
			scopeCount: self.scopeCount,
			buff: NewBuff(cast(BuffCb)self.macroAppend, self),
			context: NewCompilerContext()
		};
		type := *cast(*ast.TemplateType)(&tmplate.type.data.tmplate);

		for i: u32 = 0; i < type.datas.length; ++i {
			x := type.datas[i];
			arg := type.args[i];

			for j := 0; j < type.params.length; ++j {
				c.append("#define ", 8);
				c.ident(&type.params[j]);
				c.space();
				c.type(arg[j]);

				c.reset();
				self.newline();
			}

			if cast(u32)type.type == cast(u32)ast.TypeExprEnum.TYPE { // bog
				self.append("typedef ", 8);
				self.decTypeIdentNBuff(cast(*ast.Type)x.type, tmplate.name, buff, num.utos(i, cast(*i8)buff+1)+1);
			} else {
				self.decTypeIdentNBuff((cast(*ast.Expr)x.expr).data.funcExpr.type, tmplate.name, buff, num.utos(i, cast(*i8)buff+1)+1);
			}

			self.semicolon();
			for j := 0; j < type.params.length; ++j {
				self.newline();
				self.append("#undef ", 7);
				self.ident(&type.params[j]);
			}
			self.newline();
		}
	};
	func expr(self: *Compiler, expr: *ast.Expr){
		switch expr.type {
		case ast.ExprType.IDENT:
			self.push(names.getPrefix(expr.data.name.type));

			if names.isIndexed(expr.data.name.type) {
				self.append(expr.data.name.index.buff, expr.data.name.index.len);
			}
			self.push('_');
			self.append(cast(*i8)expr.buff, expr.len);
			break;
		case ast.ExprType.UNARY:
			self.operator(expr.data.unary.op);
			self.openParen();
			self.expr(expr.data.unary.expr);
			self.closeParen();
			break;
		case ast.ExprType.PUNARY:
			self.openParen();
			self.expr(expr.data.unary.expr);
			self.closeParen();
			self.operator(expr.data.unary.op);
			break;
		case ast.ExprType.BINARY:
			self.openParen();
			self.expr(expr.data.binary.left);
			self.closeParen();
			self.space();
			self.operator(expr.data.binary.op);
			self.space();
			self.openParen();
			self.expr(expr.data.binary.right);
			self.closeParen();
			break;
		case ast.ExprType.TERNARY:
			self.openParen();
			self.expr(expr.data.ternary.cond);
			self.closeParen();
			self.push('?');
			self.space();
			self.openParen();
			self.expr(expr.data.ternary.left);
			self.closeParen();
			self.colon();
			self.openParen();
			self.expr(expr.data.ternary.right);
			self.closeParen();
			break;
		case ast.ExprType.CAST:
			self.openParen();
			self.type(expr.data.castExpr.type);
			self.closeParen();
			self.openParen();
			self.expr(expr.data.castExpr.expr);
			self.closeParen();
			break;
		case ast.ExprType.ELEMENT:
			self.openParen();
			self.expr(expr.data.element.base);
			self.closeParen();
			self.openBrace();
			self.expr(expr.data.element.index);
			self.closeBrace();
			break;
		case ast.ExprType.SIZEOF:
			self.append("sizeof(", 7);
			self.expr(expr.data.sizeExpr.expr);
			self.closeParen();
			break;
		case ast.ExprType.CALL:
			self.callExpr(expr.data.callExpr);
			break;
		case ast.ExprType.MEMBER:
			self.memberExpr(expr);
			break;
		case ast.ExprType.NEW:
			self.newExpr(expr.data.newExpr);
			break;
		case ast.ExprType.NUM_LIT:
			self.numLit(expr);
			break;
		case ast.ExprType.COMPLIT:
			self.compLit(expr.data.compLit);
			break;
		case ast.ExprType.IS:
			self.isExpr(expr.data.isExpr);
			break;
		case ast.ExprType.FUNC:
			self.funcExpr(expr.data.funcExpr);
			break;
		case ast.ExprType.SWITCH:
			self.swtchExpr(expr.data.swtch);
			break;
		case ast.ExprType.MATCH:
			self.mtchExpr(expr.data.mtch);
			break;
		case ast.ExprType.GENERIC:
			self.genricExpr(expr.data.genric);
			break;
		case ast.ExprType.GENCALL: {
			buff: [10]i8;
			self.push('g');
			self.append(buff, num.utos(cast(u32)expr.data.genCall.index, buff));
			self.push('_');
			self.expr(cast(*ast.Expr)expr.data.genCall.expr);
			break;
		}
		default:
			self.basicLit(expr);
			break;
		}
	};
	func newExpr(self: *Compiler, newExpr: ast.NewExpr){
		if newExpr.val != null {
			self.append("I_NEW(", 6);
			self.type(newExpr.type);
			self.comma();
			self.openParen();
			self.expr(newExpr.val);
			self.closeParen();
			self.closeParen();
		} else {
			self.append("I_NEW_NV(", 9);
			self.openParen();
			self.type(newExpr.type);
			self.closeParen();
			self.closeParen();
		}
	};
	func compLit(self: *Compiler, lit: ast.CompLit){
		self.openParen();
		self.type(lit.type);
		self.closeParen();
		self.openCBrace();

		if lit.fields != null {
			for i := 0; i < lit.fields.length; ++i {
				self.push('.');
				self.ident(&lit.fields[i]);
				self.equal();
				self.space();
				self.expr(lit.values[i]);
				self.comma();
				self.space();
			}
		} else if lit.values != null {
			self.exprVec(lit.values);
		}
		self.closeCBrace();
	};
	func isExpr(self: *Compiler, isExpr: ast.IsExpr){
		self.openParen();
		self.openCBrace();
		self.append(" typeof(", 8);
		self.expr(isExpr.expr);
		self.append(") i_e = ", 8);
		self.expr(isExpr.expr);
		self.semicolon();
		self.space();
		self.pattern(isExpr.pattern, "i_e", 3);
		self.semicolon();
		self.space();
		self.closeCBrace();
		self.closeParen();
	};
	func callExpr(self: *Compiler, call: ast.CallExpr){
		self.openParen();
		self.expr(call.function);
		self.closeParen();
		self.openParen();

		t := *cast(*ast.FuncType)(&call.function.eType.data.fnc);

		if call.args == null || call.args.length == 0 {
			self.closeParen();
			return;
		}
		i := 0;

		if t.args.types.length == 0 {
			goto next;
		} else {
			goto body;
		}

		for ; i < t.args.types.length; ++i {
			self.comma();
			self.space();
		label body:
			self.expr(call.args[i]);
		}

		if i < call.args.length {
			b: [10]i8;

			self.comma();
			self.space();
		label next:
			self.append(b, num.utos(call.args.length - i, b));
		}

		for ; i < call.args.length; ++i {
			self.comma();
			self.space();
			self.expr(call.args[i]);
		}
		self.closeParen();
	};
	func memberExpr(self: *Compiler, expr: *ast.Expr){
		switch expr.eType.type {
		case ast.TypeType.TEMPLATE:
			break;
		case ast.TypeType.FUNC:
			if cast(ast.FuncTypeEnum2)expr.eType.data.fnc.type2 == ast.FuncTypeEnum2.NATIVE {
				t := (cast(*ast.Expr)(expr.data.member.base)).eType;

				if t.type == ast.TypeType.POINTER {
					t = t.data.pointer.base;
				}
				self.ident(t.data.strct.name);
				self.push('_');
				break;
			}
		default:
			self.openParen();
			self.expr(expr.data.member.base);
			self.closeParen();

			if (cast(*ast.Expr)(expr.data.member.base)).eType.type == ast.TypeType.POINTER {
				self.push('-');
				self.push('>');
			} else {
				self.dot();
			}
			break;
		}
		self.ident(expr.data.member.prop);
	};
	func numLit(self: *Compiler, lit: *ast.Expr){
		if lit.buff[1] == 'o' {
			self.push(lit.buff[0]);
			self.append(cast(*i8)lit.buff + 2, lit.len-2);
		} else {
			self.append(cast(*i8)lit.buff, lit.len);
		}
	};
	func funcExpr(self: *Compiler, fnc: ast.FuncExpr){
		self.push('^');
		self.space();
		type := *cast(*ast.FuncType)(&fnc.type.data.fnc);

		if type.returnType != null {
			self.type(type.returnType);
		} else {
			self.append("void", 4);
		}
		self.openParen();

		if type.args.types.length != 0 {
			goto end;
		}
		self.decTypeIdent(type.args.types[0], &type.args.names[0]);
		for i := 1; i < type.args.types.length; ++i {
			self.comma();
			self.space();
			self.decTypeIdent(type.args.types[i], &type.args.names[i]);
		}
	label end:
		self.closeParen();
		self.funcBody(fnc.body, type);
	};
	func funcBody(self: *Compiler, body: ast.Block, type: ast.FuncType){
		self.openCBrace();
		self.pushScope();

		v := self.context.varargs;

		if type.varargs != null {
			self.context.varargs = type.varargs;

			self.newline();
			self.indent();
			self.append("v1_Arguments ", 13);
			self.ident(type.varargs);
			self.append(" = (v1_Arguments){.p_length = i_lll};", 37);
			self.newline();
			self.indent();
			self.append("va_start(", 9);
			self.ident(type.varargs);
			self.append(".p_list, i_lll);", 16);
		} else {
			self.context.varargs = null;
		}
		self.blockNoBrace(body);
		if type.varargs != null {
			self.newline();
			self.indent();
			self.append("va_end(", 7);
			self.ident(type.varargs);
			self.append(".p_list);", 9);
		}
		self.context.varargs = v;
		self.popScope();
		self.indent();
		self.newline();
		self.indent();
		self.closeCBrace();
	};
	func swtchExpr(self: *Compiler, swtch: ast.SwitchExpr){
		self.openParen();
		self.openCBrace();
		self.pushScope();
		self.newline();
		self.indent();

		if swtch.initStmt != null {
			self.stmt(swtch.initStmt);
			self.newline();
			self.indent();
		}

		self.append("register typeof", 15);
		self.openParen();
		self.expr(swtch.defalt);
		self.closeParen();
		self.space();
		self.append("i_v", 3);
		self.semicolon();
		self.newline();
		self.indent();

		self.append("switch", 6);
		self.openParen();
		self.expr(swtch.expr);
		self.closeParen();

		self.openCBrace();
		self.pushScope();

		for i := 0; i < swtch.conds.length; ++i {
			self.newline();
			self.indent();
			self.append("case ", 5);
			self.expr(swtch.conds[i]);
			self.colon();
			self.space();
			self.append("i_v = ", 6);
			self.expr(swtch.vals[i]);
			self.semicolon();
			self.append(" break;", 7);
		}
		self.newline();
		self.indent();
		self.append("default: ", 9);
		self.append("i_v = ", 6);
		self.expr(swtch.defalt);
		self.semicolon();
		self.append(" break;", 7);

		self.popScope();
		self.newline();
		self.indent();
		self.closeCBrace();

		self.newline();
		self.indent();
		self.append("i_v;", 4);

		self.popScope();
		self.newline();
		self.indent();
		self.closeCBrace();
		self.closeParen();
	};
	func mtchExpr(self: *Compiler, mtch: ast.MatchExpr){
		self.openParen();
		self.openCBrace();
		self.pushScope();
		self.newline();
		self.indent();

		if mtch.initStmt != null {
			self.stmt(mtch.initStmt);
			self.newline();
			self.indent();
		}

		self.append("register typeof", 15);
		self.openParen();
		self.expr(mtch.defalt);
		self.closeParen();
		self.space();
		self.append("i_q", 3);
		self.semicolon();
		self.newline();
		self.indent();

		self.append("register int i_s = -1;", 22);
		self.newline();
		self.indent();
		self.append("register typeof(", 16);
		self.expr(mtch.expr);
		self.append(") i_e = ", 8);
		self.expr(mtch.expr);
		self.semicolon();

		self.newline();
		self.newline();
		self.indent();

		temp: [10]i8;

		for pattern, i := mtch.conds[0], cast(u32)0; i < mtch.conds.length; pattern = mtch.conds[++i] {
			self.append("if(", 3);
			self.pattern(pattern, "i_e", 3);
			self.closeParen();
			self.space();
			self.append("i_s = ", 6);
			self.append(cast(*i8)temp, num.utos(i, temp));
			self.semicolon();
			self.newline();
			self.indent();
			self.append("else ", 5);
		}

		self.semicolon();
		self.newline();
		self.newline();
		self.indent();
		self.append("switch(i_s)", 11);
		self.openCBrace();
		self.pushScope();

		for i := 0; i < mtch.conds.length; ++i {
			self.newline();
			self.indent();
			self.append("case ", 5);
			self.append(cast(*i8)temp, num.utos(i, temp));
			self.colon();
			self.space();
			self.append("i_q = ", 6);
			self.expr(mtch.vals[i]);
			self.semicolon();
			self.append(" break;", 7);
		}
		self.newline();
		self.indent();
		self.append("default: ", 9);
		self.append("i_q = ", 6);
		self.expr(mtch.defalt);
		self.semicolon();
		self.append(" break;", 7);

		self.popScope();
		self.newline();
		self.indent();
		self.closeCBrace();

		self.newline();
		self.indent();
		self.append("i_q;", 4);

		self.popScope();
		self.newline();
		self.indent();
		self.closeCBrace();
		self.closeParen();
	};
	func genricExpr(self: *Compiler, genric: ast.GenericExpr){
		if genric.index == genric.conds.length {
			self.expr(genric.defalt);
		} else {
			self.expr(genric.vals[genric.index]);
		}
	};
	func exprVec(self: *Compiler, e: *void){
		exprs: vec *ast.Expr = e;

		if exprs == null || exprs.length == 0 {
			return;
		}
		self.expr(exprs[0]);

		for i := 1; i < exprs.length; i++ {
			self.comma();
			self.space();
			self.expr(exprs[i]);
		}
	};
	func type(self: *Compiler, type: *ast.Type){
		switch type.type {
		case ast.TypeType.POINTER:
		case ast.TypeType.ARRAY:
		case ast.TypeType.FUNC: {
			ctx := (TypeContext){buf: (vec i8){}};

			self.typeRaw(type, &ctx);
			self.append(ctx.buf.raw, ctx.buf.length);

			ctx.buf.free();
			break;
		}
		default:
			self.typeRaw(type, null);
			break;
		}
	};
	func decType(self: *Compiler, type: *ast.Type, expr: *ast.Expr){
		switch type.type {
		case ast.TypeType.POINTER:
		case ast.TypeType.ARRAY:
		case ast.TypeType.FUNC: {
			ctx := (TypeContext){buf: (vec i8){}};

			self.typeRaw(type, &ctx);
			self.append(ctx.buf.raw, ctx.bottom);
			self.expr(expr);
			self.append(ctx.buf.raw + ctx.bottom, ctx.buf.length - ctx.bottom);

			ctx.buf.free();
			break;
		}
		default:
			self.typeRaw(type, null);
			self.space();
			self.expr(expr);
			break;
		}
	};
	func decTypeNBuff(self: *Compiler, type: *ast.Type, expr: *ast.Expr, buff: *i8, len: size_t){
		switch type.type {
		case ast.TypeType.POINTER:
		case ast.TypeType.ARRAY:
		case ast.TypeType.FUNC: {
			ctx := (TypeContext){buf: (vec i8){}};

			self.decTypeRaw(type, &ctx);
			self.append(ctx.buf.raw, ctx.bottom);
			self.append(buff, len);
			self.push('_');
			self.expr(expr);
			self.append(ctx.buf.raw + ctx.bottom, ctx.buf.length - ctx.bottom);

			ctx.buf.free();
			break;
		}
		default:
			self.decTypeRaw(type, null);
			self.space();
			self.append(buff, len);
			self.push('_');
			self.expr(expr);
			break;
		}
	};
	func decTypeIdent(self: *Compiler, type: *ast.Type, ident: *ast.IdentExpr){
		switch type.type {
		case ast.TypeType.POINTER:
		case ast.TypeType.ARRAY:
		case ast.TypeType.FUNC: {
			ctx := (TypeContext){buf: (vec i8){}};

			self.decTypeRaw(type, &ctx);
			self.append(ctx.buf.raw, ctx.bottom);
			self.ident(ident);
			self.append(ctx.buf.raw + ctx.bottom, ctx.buf.length - ctx.bottom);

			ctx.buf.free();
			break;
		}
		default:
			self.decTypeRaw(type, null);
			self.space();
			self.ident(ident);
			break;
		}
	};
	func decTypeIdentNBuff(self: *Compiler, type: *ast.Type, ident: *ast.IdentExpr, buff: *i8, len: size_t){
		switch type.type {
		case ast.TypeType.POINTER:
		case ast.TypeType.ARRAY:
		case ast.TypeType.FUNC: {
			ctx := (TypeContext){buf: (vec i8){}};
			self.decTypeRaw(type, &ctx);

			self.append(ctx.buf.raw, ctx.bottom);
			self.append(buff, len);
			self.push('_');
			self.ident(ident);
			self.append(ctx.buf.raw + ctx.bottom, ctx.buf.length - ctx.bottom);
			ctx.buf.free();
			break;
		}
		default:
			self.decTypeRaw(type, null);
			self.space();
			self.append(buff, len);
			self.push('_');
			self.ident(ident);
			break;
		}
	};
	func decTypeRaw(self: *Compiler, type: *ast.Type, ctx: *TypeContext){
		switch type.type {
		case ast.TypeType.BASIC:
			self.append(type.buff, type.len);
			self.space();
			break;
		case ast.TypeType.EXPR:
			self.expr(type.data.expr.expr);
			self.space();
			break;
		case ast.TypeType.GENCALL: {
			buff: [10]i8;
			self.push('g');
			self.append(buff, num.utos(cast(u32)type.data.genCall.index, buff));
			self.push('_');
			self.expr(cast(*ast.Expr)type.data.genCall.expr);
			self.space();
			break;
		}
		case ast.TypeType.CONST:
			self.typeRaw(type.data.cnst.base, ctx);
			break;
		case ast.TypeType.POINTER:
			ctx.insert("(*", 2);
			ctx.push(')');
			self.typeRaw(type.data.pointer.base, ctx);
			break;
		case ast.TypeType.ARRAY:
			ctx.push('[');
			ctx.num(type.data.array.size);
			ctx.push(']');
			self.typeRaw(type.data.array.base, ctx);
			break;
		case ast.TypeType.FUNC:
			self.funcType(type.data.fnc, ctx);
			break;
		case ast.TypeType.STRUCT:
			self.structType(type.data.strct, ctx);
			self.space();
			break;
		case ast.TypeType.UNION:
			self.unionType(type.data.unon);
			self.space();
			break;
		case ast.TypeType.ENUM:
			self.enumType(type.data.enm);
			self.space();
			break;
		case ast.TypeType.TUPLE:
			self.tupleType(type.data.tupl);
			self.space();
			break;
		default:
			break;
		}
	};
	func typeRaw(self: *Compiler, type: *ast.Type, ctx: *TypeContext){
		switch type.type {
		case ast.TypeType.BASIC:
			self.append(type.buff, type.len);
			self.space();
			break;
		case ast.TypeType.EXPR:
			self.expr(type.data.expr.expr);
			self.space();
			break;
		case ast.TypeType.GENCALL: {
			buff: [10]i8;
			self.push('g');
			self.append(buff, num.utos(cast(u32)type.data.genCall.index, buff));
			self.push('_');
			self.expr(cast(*ast.Expr)type.data.genCall.expr);
			self.space();
			break;
		}
		case ast.TypeType.CONST:
			self.typeRaw(type.data.cnst.base, ctx);
			break;
		case ast.TypeType.POINTER:
			ctx.insert("(*", 2);
			ctx.push(')');
			self.typeRaw(type.data.pointer.base, ctx);
			break;
		case ast.TypeType.ARRAY:
			ctx.push('[');
			ctx.num(type.data.array.size);
			ctx.push(']');
			self.typeRaw(type.data.array.base, ctx);
			break;
		case ast.TypeType.FUNC:
			self.funcType(type.data.fnc, ctx);
			break;
		case ast.TypeType.STRUCT:
			self.structType(type.data.strct, ctx);
			self.space();
			break;
		case ast.TypeType.UNION:
			self.unionType(type.data.unon);
			self.space();
			break;
		case ast.TypeType.ENUM:
			self.enumType(type.data.enm);
			self.space();
			break;
		case ast.TypeType.TUPLE:
			self.tupleType(type.data.tupl);
			self.space();
			break;
		default:
			break;
		}
	};
	func funcDecType(self: *Compiler, fnc: ast.FuncType, ident: *ast.IdentExpr){
		ctx := (TypeContext){buf: (vec i8){}};
		self.funcType(fnc, &ctx);
		self.append(ctx.buf.raw, ctx.bottom);
		self.ident(ident);
		self.append(ctx.buf.raw + ctx.bottom, ctx.buf.length - ctx.bottom);
		ctx.buf.free();
	};
	func funcDecTypeNIdent(self: *Compiler, fnc: ast.FuncType, ident: *ast.IdentExpr, ident2: *ast.IdentExpr){
		ctx := (TypeContext){buf: (vec i8){}};
		self.funcType(fnc, &ctx);
		self.append(ctx.buf.raw, ctx.bottom);
		self.ident(ident2);
		self.push('_');
		self.ident(ident);
		self.append(ctx.buf.raw + ctx.bottom, ctx.buf.length - ctx.bottom);
		ctx.buf.free();
	};
	func funcType(self: *Compiler, fnc: ast.FuncType, ctx: *TypeContext){
		if fnc.type2 == ast.FuncTypeEnum2.BLOCK {
			ctx.push(')');
			ctx.push('(');
			self.funcTypeArgs(fnc, ctx);
			ctx.push(')');

			if fnc.returnType == null {
				self.append("void ", 5);
			} else {
				self.typeRaw(fnc.returnType, ctx);
			}
			ctx.insert("(^", 2);
		} else if fnc.type2 == ast.FuncTypeEnum2.NATIVE {
			ctx.push('(');
			self.funcTypeArgs(fnc, ctx);
			ctx.push(')');

			if fnc.returnType == null {
				self.append("void ", 5);
			} else {
				self.typeRaw(fnc.returnType, ctx);
			}
		}
	};
	func funcTypeArgs(self: *Compiler, fnc: ast.FuncType, ctx: *TypeContext){
		args := fnc.args;

		c := (Compiler){
			scopeCount: self.scopeCount,
			buff: NewBuff(cast(BuffCb)ctx.append, ctx),
			context: NewCompilerContext()
		};

		if args.types.length == 0 {
			if fnc.varargs == null {
				return;
			}
			c.append("i32 i_lll, ...", 14);
			goto out;
		}

		if args.names == null {
			c.type(args.types[0]);
			for i := 1; i < args.types.length; ++i {
				c.comma();
				c.space();
				c.type(args.types[i]);
			}
			if fnc.varargs != null {
				c.comma();
				c.space();
				c.append("u16, ...", 8);
			}
		} else {
			c.decTypeIdent(args.types[0], &args.names[0]);
			for i := 1; i < args.types.length; ++i {
				c.comma();
				c.space();
				c.decTypeIdent(args.types[i], &args.names[i]);
			}
			if fnc.varargs != null {
				c.comma();
				c.space();
				c.append("i32 i_lll, ...", 14);
				c.ident(fnc.varargs);
			}
		}

	label out:
		c.free();
	};
	func structType(self: *Compiler, strct: ast.StructType, ctx: *TypeContext){
		self.append("struct ", 7);

		if strct.name != null {
			self.ident(strct.name);
			self.space();
		}
		self.openCBrace();
		self.pushScope();

		l := strct.props.length;
		for i := 0; i < l; ++i {
			s := strct.props[i];

			if s.type != ast.StmtType.DEC {
				continue;
			}
			self.newline();
			self.indent();
			self.dec(s.data.dec);
			self.semicolon();
		}

		self.popScope();
		self.newline();
		self.closeCBrace();
	};
	func unionType(self: *Compiler, unon: ast.UnionType){
		self.append("union {", 7);
		self.pushScope();

		for i := 0; i < unon.decs.length; ++i {
			self.newline();
			self.indent();
			self.decNoVal(unon.decs[i].data.dec);
			self.semicolon();
		}
		self.popScope();
		self.newline();
		self.closeCBrace();
	};
	func enumType(self: *Compiler, enm: ast.EnumType){
		self.append("enum {", 6);
		self.pushScope();

		for i := 0; i < enm.idents.length; ++i {
			self.newline();
			self.indent();
			self.ident(&enm.idents[i]);

			val := enm.values[i];

			if val != null {
				self.space();
				self.equal();
				self.space();
				self.expr(val);
			}
			self.comma();
		}
		self.popScope();
		self.newline();
		self.closeCBrace();
	};
	func tupleType(self: *Compiler, tupl: ast.TupleType){
		self.append("struct {", 8);
		self.pushScope();

		ctx := (TypeContext){buf: (vec i8){}};
		for i := 0; i < tupl.types.length; ++i {
			self.newline();
			self.indent();
			self.typeRaw(tupl.types[i], &ctx);

			self.append(ctx.buf.raw, ctx.bottom);
			self.push('_');
			self.push(65+i);
			self.append(ctx.buf.raw + ctx.bottom, ctx.buf.length - ctx.bottom);
			self.semicolon();

			ctx.buf.length = 0;
			ctx.bottom = 0;
		}
		ctx.buf.free();

		self.popScope();
		self.newline();
		self.closeCBrace();
	};
	func pattern(self: *Compiler, pattern: *ast.Pattern, buff: *i8, len: size_t){
		switch pattern.type {
		case ast.PatternType.EXPR:
			self.append(buff, len);
			self.append(" == (", 5);
			self.expr(pattern.data.expr.expr);
			self.closeParen();
			break;
		case ast.PatternType.UNARY:
			self.append(buff, len);
			self.space();
			self.operator(pattern.data.unary.op);
			self.space();
			self.openParen();
			self.expr(pattern.data.unary.expr);
			self.closeParen();
			break;
		case ast.PatternType.BINARY:
			self.openParen();
			self.pattern(pattern.data.binary.left, buff, len);
			self.closeParen();
			self.space();
			self.operator(pattern.data.binary.op);
			self.space();
			self.openParen();
			self.pattern(pattern.data.binary.right, buff, len);
			self.closeParen();
			break;
		case ast.PatternType.RANGE:
			self.rangePattern(pattern.data.range, buff, len);
			break;
		case ast.PatternType.ELRANGE:
			self.elRangePattern(pattern.data.elRange, buff, len);
			break;
		case ast.PatternType.COMP:
			self.compPattern(pattern.data.comp, buff, len);
			break;
		}
	};
	func compPattern(self: *Compiler, comp: ast.CompPattern, buff: *i8, len: size_t){
		if comp.fields == null {
			self.append("({ register typeof(", 19);
			self.append(buff, len);
			self.append("[0]) *i_t = ", 12);
			self.append(buff, len);
			self.semicolon();
			self.space();

			self.append("register typeof(", 16);
			self.append(buff, len);
			self.append("[0]) *i_v = i_t; ", 17);

			p, i := comp.values[0], 0;

			goto body;
			for ; i < comp.values.length; p = comp.values[++i] {
				self.append(" && i_v++ && ", 13);
			label body:
				self.pattern(p, "*i_v", 4);
			}
		} else {
			self.append("({ register typeof(", 19);
			self.append(buff, len);
			self.append(") i_t = ", 8);
			self.append(buff, len);
			self.semicolon();
			self.space();

			self.append("register typeof(", 16);
			self.append(buff, len);
			self.append(") i_v = i_t; ", 13);

			p, q, i := comp.values[0], comp.fields[0], 1;
			b: [30]i8;

			mem.copy(b, "i_v", 3);
			b[3] = '.';

			goto body2;
			for ;i < comp.values.length; ++i {
				self.append(" && i_v++ && ", 13);

			label body2:
				mem.copy(cast(*i8)b+4, q.tok.buff, q.tok.len);
				self.pattern(p, b, q.tok.len+4);

				p, q = comp.values[i], comp.fields[i];
			}
		}
		self.semicolon();
		self.closeCBrace();
		self.closeParen();
	};
	func elRangePattern(self: *Compiler, elRange: ast.ElementRangePattern, buff: *i8, len: size_t){
		if elRange.val == null {
			self.append("({ i_v += ", 10);
			self.expr(elRange.len);
			self.append("; true; })", 10);
			return;
		}

		self.append("({ typeof(", 10);
		self.expr(elRange.len);
		self.append(") i_l = ", 8);
		self.expr(elRange.len);
		self.semicolon();
		self.space();

		if elRange.dotdot == false {
			self.append("(i_l-- && (", 16);
			self.pattern(elRange.val, buff, len);
		} else {
			self.append("typeof(", 7);
			self.expr(elRange.val.data.expr.expr);
			self.append("[0]) *i_o = ", 12);
			self.expr(elRange.val.data.expr.expr);
			self.semicolon();
			self.space();

			self.append("while(i_l-- && (", 16);
			self.append(buff, len);
			self.append(" == *i_o++)", 11);
		}
		self.append("){ i_v++; } i_l == -1; })", 25);
	};
	func rangePattern(self: *Compiler, range: ast.RangePattern, buff: *i8, len: size_t){
		if range.left == null {
			self.append(buff, len);

			switch range.type {
			case ast.RangeType.NONE:
				self.append(" < ", 3);
				break;
			default:
				self.append(" <= ", 4);
				break;
			}
			self.openParen();
			self.expr(range.right);
			self.closeParen();
		} else if range.right == null {
			self.append(buff, len);

			switch range.type {
			case ast.RangeType.NONE:
				self.append(" > ", 3);
				break;
			default:
				self.append(" >= ", 4);
				break;
			}
			self.openParen();
			self.expr(range.left);
			self.closeParen();
		} else {
			self.openParen();
			self.append(buff, len);

			switch range.type {
			case ast.RangeType.NONE:
			case ast.RangeType.RIGHT:
				self.append(" > ", 3);
				break;
			default:
				self.append(" >= ", 4);
				break;
			}
			self.openParen();
			self.expr(range.left);
			self.append(")) && (", 7);
			self.append(buff, len);

			switch range.type {
			case ast.RangeType.NONE:
			case ast.RangeType.LEFT:
				self.append(" < ", 3);
				break;
			default:
				self.append(" <= ", 4);
				break;
			}
			self.openParen();
			self.expr(range.right);
			self.closeParen();
			self.closeParen();
		}
	};
	func free(self: *Compiler){
		self.buff.checkNFlush();
		self.context.free();
	};
	func reset(self: *Compiler){
		self.buff.checkNFlush();
		self.context.reset();
	};
};
export func NewCompiler(scopeCount: u32, cb: func(*void, *i8, u32), data: *void) Compiler {
	return (Compiler){
		scopeCount: scopeCount,
		buff:    NewBuff(cb, data),
		context: NewCompilerContext()
	};
};
